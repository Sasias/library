
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Unicode对象和编解码器 &#8212; Python 3.8.19 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.8.19 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="元组对象" href="tuple.html" />
    <link rel="prev" title="字节数组对象" href="bytearray.html" />
    <link rel="canonical" href="https://docs.python.org/3/c-api/unicode.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">Unicode对象和编解码器</a><ul>
<li><a class="reference internal" href="#unicode-objects">Unicode对象</a><ul>
<li><a class="reference internal" href="#unicode-type">Unicode类型</a></li>
<li><a class="reference internal" href="#unicode-character-properties">Unicode字符属性</a></li>
<li><a class="reference internal" href="#creating-and-accessing-unicode-strings">创建和访问 Unicode 字符串</a></li>
<li><a class="reference internal" href="#deprecated-py-unicode-apis">已弃用的 Py_UNICODE API</a></li>
<li><a class="reference internal" href="#locale-encoding">语言区域编码格式</a></li>
<li><a class="reference internal" href="#file-system-encoding">文件系统编码格式</a></li>
<li><a class="reference internal" href="#wchar-t-support">wchar_t 支持</a></li>
</ul>
</li>
<li><a class="reference internal" href="#built-in-codecs">内置编解码器</a><ul>
<li><a class="reference internal" href="#generic-codecs">泛型编解码器</a></li>
<li><a class="reference internal" href="#utf-8-codecs">UTF-8 编解码器</a></li>
<li><a class="reference internal" href="#utf-32-codecs">UTF-32 编解码器</a></li>
<li><a class="reference internal" href="#utf-16-codecs">UTF-16 编解码器</a></li>
<li><a class="reference internal" href="#utf-7-codecs">UTF-7 编解码器</a></li>
<li><a class="reference internal" href="#unicode-escape-codecs">Unicode-Escape 编解码器</a></li>
<li><a class="reference internal" href="#raw-unicode-escape-codecs">Raw-Unicode-Escape 编解码器</a></li>
<li><a class="reference internal" href="#latin-1-codecs">Latin-1 编解码器</a></li>
<li><a class="reference internal" href="#ascii-codecs">ASCII 编解码器</a></li>
<li><a class="reference internal" href="#character-map-codecs">字符映射编解码器</a></li>
<li><a class="reference internal" href="#mbcs-codecs-for-windows">Windows 中的 MBCS 编解码器</a></li>
<li><a class="reference internal" href="#methods-slots">方法和槽位</a></li>
</ul>
</li>
<li><a class="reference internal" href="#methods-and-slot-functions">方法与槽位函数</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="bytearray.html"
                        title="上一章">字节数组对象</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="tuple.html"
                        title="下一章">元组对象</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/c-api/unicode.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="tuple.html" title="元组对象"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="bytearray.html" title="字节数组对象"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.8.19 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API 参考手册</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="concrete.html" accesskey="U">具体的对象层</a> &#187;</li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="unicode-objects-and-codecs">
<span id="unicodeobjects"></span><h1>Unicode对象和编解码器<a class="headerlink" href="#unicode-objects-and-codecs" title="永久链接至标题">¶</a></h1>
<section id="unicode-objects">
<h2>Unicode对象<a class="headerlink" href="#unicode-objects" title="永久链接至标题">¶</a></h2>
<p>自从python3.3中实现了 <span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0393"><strong>PEP 393</strong></a> 以来，Unicode对象在内部使用各种表示形式，以便在保持内存效率的同时处理完整范围的Unicode字符。对于所有代码点都低于128、256或65536的字符串，有一些特殊情况；否则，代码点必须低于1114112（这是完整的Unicode范围）。</p>
<p><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> and UTF-8 representations are created on demand and cached
in the Unicode object.  The <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> representation is deprecated
and inefficient.</p>
<p>由于旧API和新API之间的转换，Unicode对象内部可以处于两种状态，这取决于它们的创建方式：</p>
<ul class="simple">
<li><p>“规范”Unicode对象是由非弃用的Unicode API创建的所有对象。它们使用实现所允许的最有效的表达方式。</p></li>
<li><p>&quot;legacy&quot; Unicode objects have been created through one of the deprecated
APIs (typically <a class="reference internal" href="#c.PyUnicode_FromUnicode" title="PyUnicode_FromUnicode"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromUnicode()</span></code></a>) and only bear the
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> representation; you will have to call
<a class="reference internal" href="#c.PyUnicode_READY" title="PyUnicode_READY"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READY()</span></code></a> on them before calling any other API.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>The &quot;legacy&quot; Unicode object will be removed in Python 3.12 with deprecated
APIs. All Unicode objects will be &quot;canonical&quot; since then. See <span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0623"><strong>PEP 623</strong></a>
for more information.</p>
</div>
<section id="unicode-type">
<h3>Unicode类型<a class="headerlink" href="#unicode-type" title="永久链接至标题">¶</a></h3>
<p>以下是用于Python中Unicode实现的基本Unicode对象类型：</p>
<dl class="type">
<dt id="c.Py_UCS4">
<code class="sig-name descname">Py_UCS4</code><a class="headerlink" href="#c.Py_UCS4" title="永久链接至目标">¶</a></dt>
<dt id="c.Py_UCS2">
<code class="sig-name descname">Py_UCS2</code><a class="headerlink" href="#c.Py_UCS2" title="永久链接至目标">¶</a></dt>
<dt id="c.Py_UCS1">
<code class="sig-name descname">Py_UCS1</code><a class="headerlink" href="#c.Py_UCS1" title="永久链接至目标">¶</a></dt>
<dd><p>这些类型是无符号整数类型的类型定义，其宽度足以分别包含 32 位、16 位和 8 位字符。 当需要处理单个 Unicode 字符时，请使用 <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UCS4</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="type">
<dt id="c.Py_UNICODE">
<code class="sig-name descname">Py_UNICODE</code><a class="headerlink" href="#c.Py_UNICODE" title="永久链接至目标">¶</a></dt>
<dd><p>这是 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> 的类型定义，根据平台的不同它可能为 16 位类型或 32 位类型。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>在以前的版本中，这是16位类型还是32位类型，这取决于您在构建时选择的是“窄”还是“宽”Unicode版本的Python。</p>
</div>
</dd></dl>

<dl class="type">
<dt id="c.PyASCIIObject">
<code class="sig-name descname">PyASCIIObject</code><a class="headerlink" href="#c.PyASCIIObject" title="永久链接至目标">¶</a></dt>
<dt id="c.PyCompactUnicodeObject">
<code class="sig-name descname">PyCompactUnicodeObject</code><a class="headerlink" href="#c.PyCompactUnicodeObject" title="永久链接至目标">¶</a></dt>
<dt id="c.PyUnicodeObject">
<code class="sig-name descname">PyUnicodeObject</code><a class="headerlink" href="#c.PyUnicodeObject" title="永久链接至目标">¶</a></dt>
<dd><p>这些关于 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> 的子类型表示了一个 Python Unicode 对象。 在几乎所有情形下，它们不应该被直接使用，因为所有处理 Unicode 对象的 API 函数都接受并返回 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> 类型的指针。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="var">
<dt id="c.PyUnicode_Type">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a> <code class="sig-name descname">PyUnicode_Type</code><a class="headerlink" href="#c.PyUnicode_Type" title="永久链接至目标">¶</a></dt>
<dd><p>这个 <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 实例代表 Python Unicode 类型。 它作为 <code class="docutils literal notranslate"><span class="pre">str</span></code> 公开给 Python 代码。</p>
</dd></dl>

<p>The following APIs are really C macros and can be used to do fast checks and to
access internal read-only data of Unicode objects:</p>
<dl class="function">
<dt id="c.PyUnicode_Check">
int <code class="sig-name descname">PyUnicode_Check</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Check" title="永久链接至目标">¶</a></dt>
<dd><p>Return true if the object <em>o</em> is a Unicode object or an instance of a Unicode
subtype.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_CheckExact">
int <code class="sig-name descname">PyUnicode_CheckExact</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_CheckExact" title="永久链接至目标">¶</a></dt>
<dd><p>Return true if the object <em>o</em> is a Unicode object, but not an instance of a
subtype.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_READY">
int <code class="sig-name descname">PyUnicode_READY</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_READY" title="永久链接至目标">¶</a></dt>
<dd><p>确保字符串对象*o*处于“规范的”表达方式。在使用下面描述的任何访问宏之前，这是必需的。</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">0</span></code> on success and <code class="docutils literal notranslate"><span class="pre">-1</span></code> with an exception set on failure, which in
particular happens if memory allocation fails.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.10, will be removed in version 3.12: </span>This API will be removed with <a class="reference internal" href="#c.PyUnicode_FromUnicode" title="PyUnicode_FromUnicode"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromUnicode()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GET_LENGTH">
Py_ssize_t <code class="sig-name descname">PyUnicode_GET_LENGTH</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GET_LENGTH" title="永久链接至目标">¶</a></dt>
<dd><p>返回Unicode字符串的长度（以代码点为单位）*o*必须是“规范”表达方式中的Unicode对象（未选中）。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_1BYTE_DATA">
<a class="reference internal" href="#c.Py_UCS1" title="Py_UCS1">Py_UCS1</a>* <code class="sig-name descname">PyUnicode_1BYTE_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_1BYTE_DATA" title="永久链接至目标">¶</a></dt>
<dt id="c.PyUnicode_2BYTE_DATA">
<a class="reference internal" href="#c.Py_UCS2" title="Py_UCS2">Py_UCS2</a>* <code class="sig-name descname">PyUnicode_2BYTE_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_2BYTE_DATA" title="永久链接至目标">¶</a></dt>
<dt id="c.PyUnicode_4BYTE_DATA">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a>* <code class="sig-name descname">PyUnicode_4BYTE_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_4BYTE_DATA" title="永久链接至目标">¶</a></dt>
<dd><p>Return a pointer to the canonical representation cast to UCS1, UCS2 or UCS4
integer types for direct character access.  No checks are performed if the
canonical representation has the correct character size; use
<a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_KIND()</span></code></a> to select the right macro.  Make sure
<a class="reference internal" href="#c.PyUnicode_READY" title="PyUnicode_READY"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READY()</span></code></a> has been called before accessing this.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.PyUnicode_WCHAR_KIND">
<code class="sig-name descname">PyUnicode_WCHAR_KIND</code><a class="headerlink" href="#c.PyUnicode_WCHAR_KIND" title="永久链接至目标">¶</a></dt>
<dt id="c.PyUnicode_1BYTE_KIND">
<code class="sig-name descname">PyUnicode_1BYTE_KIND</code><a class="headerlink" href="#c.PyUnicode_1BYTE_KIND" title="永久链接至目标">¶</a></dt>
<dt id="c.PyUnicode_2BYTE_KIND">
<code class="sig-name descname">PyUnicode_2BYTE_KIND</code><a class="headerlink" href="#c.PyUnicode_2BYTE_KIND" title="永久链接至目标">¶</a></dt>
<dt id="c.PyUnicode_4BYTE_KIND">
<code class="sig-name descname">PyUnicode_4BYTE_KIND</code><a class="headerlink" href="#c.PyUnicode_4BYTE_KIND" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_KIND()</span></code></a> 宏的值。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.10, will be removed in version 3.12: </span><code class="docutils literal notranslate"><span class="pre">PyUnicode_WCHAR_KIND</span></code> 已被弃用。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_KIND">
int <code class="sig-name descname">PyUnicode_KIND</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_KIND" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个PyUnicode类常量（见上文），指示此Unicode对象用于存储其数据的每个字符的字节数*o*必须是“规范”表达方式中的Unicode对象（未选中）。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DATA">
void* <code class="sig-name descname">PyUnicode_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DATA" title="永久链接至目标">¶</a></dt>
<dd><p>返回指向原始Unicode缓冲区的空指针*o*必须是“规范”表达方式中的Unicode对象（未选中）。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_WRITE">
void <code class="sig-name descname">PyUnicode_WRITE</code><span class="sig-paren">(</span>int<em> kind</em>, void<em> *data</em>, Py_ssize_t<em> index</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_WRITE" title="永久链接至目标">¶</a></dt>
<dd><p>Write into a canonical representation <em>data</em> (as obtained with
<a class="reference internal" href="#c.PyUnicode_DATA" title="PyUnicode_DATA"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DATA()</span></code></a>).  This macro does not do any sanity checks and is
intended for usage in loops.  The caller should cache the <em>kind</em> value and
<em>data</em> pointer as obtained from other macro calls.  <em>index</em> is the index in
the string (starts at 0) and <em>value</em> is the new code point value which should
be written to that location.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_READ">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a> <code class="sig-name descname">PyUnicode_READ</code><span class="sig-paren">(</span>int<em> kind</em>, void<em> *data</em>, Py_ssize_t<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_READ" title="永久链接至目标">¶</a></dt>
<dd><p>从规范表示的 <em>data</em> (如同用 <a class="reference internal" href="#c.PyUnicode_DATA" title="PyUnicode_DATA"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DATA()</span></code></a> 获取) 中读取一个码位。 不会执行检查或就绪调用。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_READ_CHAR">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a> <code class="sig-name descname">PyUnicode_READ_CHAR</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em>, Py_ssize_t<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_READ_CHAR" title="永久链接至目标">¶</a></dt>
<dd><p>从 Unicode 对象 <em>o</em> 读取一个字符，必须使用“规范”表示形式。 如果你执行行多次连续读取则此函数的效率将低于 <a class="reference internal" href="#c.PyUnicode_READ" title="PyUnicode_READ"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READ()</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.PyUnicode_MAX_CHAR_VALUE">
<code class="sig-name descname">PyUnicode_MAX_CHAR_VALUE</code><span class="sig-paren">(</span>o<span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_MAX_CHAR_VALUE" title="永久链接至目标">¶</a></dt>
<dd><p>返回适合于基于*o*创建另一个字符串的最大代码点，该字符串必须在“规范”表达方式中。这始终是一种近似，但比在字符串上迭代更有效。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_ClearFreeList">
int <code class="sig-name descname">PyUnicode_ClearFreeList</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_ClearFreeList" title="永久链接至目标">¶</a></dt>
<dd><p>清空释放列表。 返回所释放的条目数。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GET_SIZE">
Py_ssize_t <code class="sig-name descname">PyUnicode_GET_SIZE</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GET_SIZE" title="永久链接至目标">¶</a></dt>
<dd><p>Return the size of the deprecated <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> representation, in
code units (this includes surrogate pairs as 2 units).  <em>o</em> has to be a
Unicode object (not checked).</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>旧式 Unicode API 的一部分，请迁移到使用 <a class="reference internal" href="#c.PyUnicode_GET_LENGTH" title="PyUnicode_GET_LENGTH"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_GET_LENGTH()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GET_DATA_SIZE">
Py_ssize_t <code class="sig-name descname">PyUnicode_GET_DATA_SIZE</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GET_DATA_SIZE" title="永久链接至目标">¶</a></dt>
<dd><p>Return the size of the deprecated <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> representation in
bytes.  <em>o</em> has to be a Unicode object (not checked).</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>旧式 Unicode API 的一部分，请迁移到使用 <a class="reference internal" href="#c.PyUnicode_GET_LENGTH" title="PyUnicode_GET_LENGTH"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_GET_LENGTH()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AS_UNICODE">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <code class="sig-name descname">PyUnicode_AS_UNICODE</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AS_UNICODE" title="永久链接至目标">¶</a></dt>
<dt id="c.PyUnicode_AS_DATA">
const char* <code class="sig-name descname">PyUnicode_AS_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AS_DATA" title="永久链接至目标">¶</a></dt>
<dd><p>Return a pointer to a <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> representation of the object.  The
returned buffer is always terminated with an extra null code point.  It
may also contain embedded null code points, which would cause the string
to be truncated when used in most C functions.  The <code class="docutils literal notranslate"><span class="pre">AS_DATA</span></code> form
casts the pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code>.  The <em>o</em> argument has to be
a Unicode object (not checked).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>This macro is now inefficient -- because in many cases the
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> representation does not exist and needs to be created
-- and can fail (return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> with an exception set).  Try to port the
code to use the new <code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_nBYTE_DATA()</span></code> macros or use
<a class="reference internal" href="#c.PyUnicode_WRITE" title="PyUnicode_WRITE"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_WRITE()</span></code></a> or <a class="reference internal" href="#c.PyUnicode_READ" title="PyUnicode_READ"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READ()</span></code></a>.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>旧式 Unicode API 的一部分，请迁移到使用 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_nBYTE_DATA()</span></code> 宏族。</p>
</div>
</dd></dl>

</section>
<section id="unicode-character-properties">
<h3>Unicode字符属性<a class="headerlink" href="#unicode-character-properties" title="永久链接至标题">¶</a></h3>
<p>Unicode提供了许多不同的字符特性。最常需要的宏可以通过这些宏获得，这些宏根据Python配置映射到C函数。</p>
<dl class="function">
<dt id="c.Py_UNICODE_ISSPACE">
int <code class="sig-name descname">Py_UNICODE_ISSPACE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISSPACE" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <em>ch</em> 是否为空白字符返回 <code class="docutils literal notranslate"><span class="pre">1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISLOWER">
int <code class="sig-name descname">Py_UNICODE_ISLOWER</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISLOWER" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <em>ch</em> 是否为小写字符返回 <code class="docutils literal notranslate"><span class="pre">1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISUPPER">
int <code class="sig-name descname">Py_UNICODE_ISUPPER</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISUPPER" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <em>ch</em> 是否为大写字符返回 <code class="docutils literal notranslate"><span class="pre">1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">0</span></code></p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISTITLE">
int <code class="sig-name descname">Py_UNICODE_ISTITLE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISTITLE" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <em>ch</em> 是否为标题化的大小写返回 <code class="docutils literal notranslate"><span class="pre">1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISLINEBREAK">
int <code class="sig-name descname">Py_UNICODE_ISLINEBREAK</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISLINEBREAK" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <em>ch</em> 是否为换行类字符返回 <code class="docutils literal notranslate"><span class="pre">1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISDECIMAL">
int <code class="sig-name descname">Py_UNICODE_ISDECIMAL</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISDECIMAL" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <em>ch</em> 是否为十进制数字符返回 <code class="docutils literal notranslate"><span class="pre">1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISDIGIT">
int <code class="sig-name descname">Py_UNICODE_ISDIGIT</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISDIGIT" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <em>ch</em> 是否为数码类字符返回 <code class="docutils literal notranslate"><span class="pre">1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISNUMERIC">
int <code class="sig-name descname">Py_UNICODE_ISNUMERIC</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISNUMERIC" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <em>ch</em> 是否为数值类字符返回 <code class="docutils literal notranslate"><span class="pre">1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISALPHA">
int <code class="sig-name descname">Py_UNICODE_ISALPHA</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISALPHA" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <em>ch</em> 是否为字母类字符返回 <code class="docutils literal notranslate"><span class="pre">1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISALNUM">
int <code class="sig-name descname">Py_UNICODE_ISALNUM</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISALNUM" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <em>ch</em> 是否为字母数字类字符返回 <code class="docutils literal notranslate"><span class="pre">1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISPRINTABLE">
int <code class="sig-name descname">Py_UNICODE_ISPRINTABLE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISPRINTABLE" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <em>ch</em> 是否为可打印字符返回 <code class="docutils literal notranslate"><span class="pre">1</span></code> 或``0``。 不可打印字符是指在 Unicode 字符数据库中被定义为 &quot;Other&quot; 或 &quot;Separator&quot; 的字符，例外情况是 ASCII 空格 (0x20) 被视为可打印字符。 (请注意在此语境下可打印字符是指当在字符串上发起调用 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 时不应被转义的字符。 它们字符串写入 <a class="reference internal" href="../library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a> 或 <a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> 时所需的处理无关)。</p>
</dd></dl>

<p>这些 API 可用于快速直接的字符转换：</p>
<dl class="function">
<dt id="c.Py_UNICODE_TOLOWER">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a> <code class="sig-name descname">Py_UNICODE_TOLOWER</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TOLOWER" title="永久链接至目标">¶</a></dt>
<dd><p>返回转换为小写形式的字符 <em>ch</em>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.3 版后已移除: </span>此函数使用简单的大小写映射。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TOUPPER">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a> <code class="sig-name descname">Py_UNICODE_TOUPPER</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TOUPPER" title="永久链接至目标">¶</a></dt>
<dd><p>返回转换为大写形式的字符 <em>ch</em>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.3 版后已移除: </span>此函数使用简单的大小写映射。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TOTITLE">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a> <code class="sig-name descname">Py_UNICODE_TOTITLE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TOTITLE" title="永久链接至目标">¶</a></dt>
<dd><p>返回转换为标题大小写形式的字符 <em>ch</em>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.3 版后已移除: </span>此函数使用简单的大小写映射。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TODECIMAL">
int <code class="sig-name descname">Py_UNICODE_TODECIMAL</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TODECIMAL" title="永久链接至目标">¶</a></dt>
<dd><p>Return the character <em>ch</em> converted to a decimal positive integer.  Return
<code class="docutils literal notranslate"><span class="pre">-1</span></code> if this is not possible.  This macro does not raise exceptions.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TODIGIT">
int <code class="sig-name descname">Py_UNICODE_TODIGIT</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TODIGIT" title="永久链接至目标">¶</a></dt>
<dd><p>Return the character <em>ch</em> converted to a single digit integer. Return <code class="docutils literal notranslate"><span class="pre">-1</span></code> if
this is not possible.  This macro does not raise exceptions.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TONUMERIC">
double <code class="sig-name descname">Py_UNICODE_TONUMERIC</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TONUMERIC" title="永久链接至目标">¶</a></dt>
<dd><p>Return the character <em>ch</em> converted to a double. Return <code class="docutils literal notranslate"><span class="pre">-1.0</span></code> if this is not
possible.  This macro does not raise exceptions.</p>
</dd></dl>

<p>这些 API 可被用来操作代理项：</p>
<dl class="macro">
<dt id="c.Py_UNICODE_IS_SURROGATE">
<code class="sig-name descname">Py_UNICODE_IS_SURROGATE</code><span class="sig-paren">(</span>ch<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_IS_SURROGATE" title="永久链接至目标">¶</a></dt>
<dd><p>检测 <em>ch</em> 是否为代理项 (<code class="docutils literal notranslate"><span class="pre">0xD800</span> <span class="pre">&lt;=</span> <span class="pre">ch</span> <span class="pre">&lt;=</span> <span class="pre">0xDFFF</span></code>)。</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_UNICODE_IS_HIGH_SURROGATE">
<code class="sig-name descname">Py_UNICODE_IS_HIGH_SURROGATE</code><span class="sig-paren">(</span>ch<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_IS_HIGH_SURROGATE" title="永久链接至目标">¶</a></dt>
<dd><p>检测 <em>ch</em> 是否为高代理项 (<code class="docutils literal notranslate"><span class="pre">0xD800</span> <span class="pre">&lt;=</span> <span class="pre">ch</span> <span class="pre">&lt;=</span> <span class="pre">0xDBFF</span></code>)。</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_UNICODE_IS_LOW_SURROGATE">
<code class="sig-name descname">Py_UNICODE_IS_LOW_SURROGATE</code><span class="sig-paren">(</span>ch<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_IS_LOW_SURROGATE" title="永久链接至目标">¶</a></dt>
<dd><p>检测 <em>ch</em> 是否为低代理项 (<code class="docutils literal notranslate"><span class="pre">0xDC00</span> <span class="pre">&lt;=</span> <span class="pre">ch</span> <span class="pre">&lt;=</span> <span class="pre">0xDFFF</span></code>)。</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_UNICODE_JOIN_SURROGATES">
<code class="sig-name descname">Py_UNICODE_JOIN_SURROGATES</code><span class="sig-paren">(</span>high, low<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_JOIN_SURROGATES" title="永久链接至目标">¶</a></dt>
<dd><p>Join two surrogate characters and return a single Py_UCS4 value.
<em>high</em> and <em>low</em> are respectively the leading and trailing surrogates in a
surrogate pair.</p>
</dd></dl>

</section>
<section id="creating-and-accessing-unicode-strings">
<h3>创建和访问 Unicode 字符串<a class="headerlink" href="#creating-and-accessing-unicode-strings" title="永久链接至标题">¶</a></h3>
<p>要创建 Unicode 对象和访问其基本序列属性，请使用这些 API：</p>
<dl class="function">
<dt id="c.PyUnicode_New">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_New</code><span class="sig-paren">(</span>Py_ssize_t<em> size</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> maxchar</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_New" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>创建一个新的 Unicode 对象。 <em>maxchar</em> 应为可放入字符串的实际最大码位。 作为一个近似值，它可被向上舍入到序列 127, 255, 65535, 1114111 中最接近的值。</p>
<p>这是分配新的 Unicode 对象的推荐方式。 使用此函数创建的对象不可改变大小。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromKindAndData">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromKindAndData</code><span class="sig-paren">(</span>int<em> kind</em>, const void<em> *buffer</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromKindAndData" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>以给定的 <em>kind</em> 创建一个新的 Unicode 对象（可能的值为 <a class="reference internal" href="#c.PyUnicode_1BYTE_KIND" title="PyUnicode_1BYTE_KIND"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyUnicode_1BYTE_KIND</span></code></a> 等，即 <a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_KIND()</span></code></a> 所返回的值）。 <em>buffer</em> 必须指向由此分类所给出的，以每字符 1, 2 或 4 字节单位的 <em>size</em> 大小的数组。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromStringAndSize">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromStringAndSize</code><span class="sig-paren">(</span>const char<em> *u</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromStringAndSize" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object from the char buffer <em>u</em>.  The bytes will be
interpreted as being UTF-8 encoded.  The buffer is copied into the new
object. If the buffer is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the return value might be a shared
object, i.e. modification of the data is not allowed.</p>
<p>If <em>u</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, this function behaves like <a class="reference internal" href="#c.PyUnicode_FromUnicode" title="PyUnicode_FromUnicode"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromUnicode()</span></code></a>
with the buffer set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  This usage is deprecated in favor of
<a class="reference internal" href="#c.PyUnicode_New" title="PyUnicode_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_New()</span></code></a>, and will be removed in Python 3.12.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">PyUnicode_FromString</code><span class="sig-paren">(</span>const char<em> *u</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromString" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>根据 UTF-8 编码的以空值结束的字符缓冲区 <em>u</em> 创建一个 Unicode 对象。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromFormat">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromFormat</code><span class="sig-paren">(</span>const char<em> *format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromFormat" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Take a C <code class="xref c c-func docutils literal notranslate"><span class="pre">printf()</span></code>-style <em>format</em> string and a variable number of
arguments, calculate the size of the resulting Python Unicode string and return
a string with the values formatted into it.  The variable arguments must be C
types and must correspond exactly to the format characters in the <em>format</em>
ASCII-encoded string. The following format characters are allowed:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 28%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>格式字符</p></th>
<th class="head"><p>类型</p></th>
<th class="head"><p>注释</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%%</span></code></p></td>
<td><p><em>不适用</em></p></td>
<td><p>文字%字符。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%c</span></code></p></td>
<td><p>int</p></td>
<td><p>单个字符，表示为C 语言的整型。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%d</span></code></p></td>
<td><p>int</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%d&quot;)</span></code>. <a class="footnote-reference brackets" href="#id14" id="id1">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%u</span></code></p></td>
<td><p>unsigned int</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%u&quot;)</span></code>. <a class="footnote-reference brackets" href="#id14" id="id2">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%ld</span></code></p></td>
<td><p>长整型</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%ld&quot;)</span></code>. <a class="footnote-reference brackets" href="#id14" id="id3">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%li</span></code></p></td>
<td><p>长整型</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%li&quot;)</span></code>. <a class="footnote-reference brackets" href="#id14" id="id4">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%lu</span></code></p></td>
<td><p>unsigned long</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%lu&quot;)</span></code>. <a class="footnote-reference brackets" href="#id14" id="id5">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%lld</span></code></p></td>
<td><p>long long</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%lld&quot;)</span></code>. <a class="footnote-reference brackets" href="#id14" id="id6">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%lli</span></code></p></td>
<td><p>long long</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%lli&quot;)</span></code>. <a class="footnote-reference brackets" href="#id14" id="id7">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%llu</span></code></p></td>
<td><p>unsigned long long</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%llu&quot;)</span></code>. <a class="footnote-reference brackets" href="#id14" id="id8">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%zd</span></code></p></td>
<td><p>Py_ssize_t</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%zd&quot;)</span></code>. <a class="footnote-reference brackets" href="#id14" id="id9">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%zi</span></code></p></td>
<td><p>Py_ssize_t</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%zi&quot;)</span></code>. <a class="footnote-reference brackets" href="#id14" id="id10">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%zu</span></code></p></td>
<td><p>size_t</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%zu&quot;)</span></code>. <a class="footnote-reference brackets" href="#id14" id="id11">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%i</span></code></p></td>
<td><p>int</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%i&quot;)</span></code>. <a class="footnote-reference brackets" href="#id14" id="id12">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%x</span></code></p></td>
<td><p>int</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%x&quot;)</span></code>. <a class="footnote-reference brackets" href="#id14" id="id13">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%s</span></code></p></td>
<td><p>const char*</p></td>
<td><p>以 null 为终止符的 C 字符数组。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%p</span></code></p></td>
<td><p>const void*</p></td>
<td><p>一个 C 指针的十六进制表示形式。 基本等价于 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%p&quot;)</span></code> 但它会确保以字面值 <code class="docutils literal notranslate"><span class="pre">0x</span></code> 开头，不论系统平台上 <code class="docutils literal notranslate"><span class="pre">printf</span></code> 的输出是什么。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%A</span></code></p></td>
<td><p>PyObject*</p></td>
<td><p><a class="reference internal" href="../library/functions.html#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a> 调用的结果。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%U</span></code></p></td>
<td><p>PyObject*</p></td>
<td><p>一个 Unicode 对象。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%V</span></code></p></td>
<td><p>PyObject*,
const char*</p></td>
<td><p>一个 Unicode 对象 (可以为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>) 和一个以空值结束的 C 字符数组作为第二个形参（如果第一个形参为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，第二个形参将被使用）。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%S</span></code></p></td>
<td><p>PyObject*</p></td>
<td><p>调用 <a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Str()</span></code></a> 的结果。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%R</span></code></p></td>
<td><p>PyObject*</p></td>
<td><p>调用 <a class="reference internal" href="object.html#c.PyObject_Repr" title="PyObject_Repr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Repr()</span></code></a> 的结果。</p></td>
</tr>
</tbody>
</table>
<p>An unrecognized format character causes all the rest of the format string to be
copied as-is to the result string, and any extra arguments discarded.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>The width formatter unit is number of characters rather than bytes.
The precision formatter unit is number of bytes for <code class="docutils literal notranslate"><span class="pre">&quot;%s&quot;</span></code> and
<code class="docutils literal notranslate"><span class="pre">&quot;%V&quot;</span></code> (if the <code class="docutils literal notranslate"><span class="pre">PyObject*</span></code> argument is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>), and a number of
characters for <code class="docutils literal notranslate"><span class="pre">&quot;%A&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%U&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%S&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%R&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;%V&quot;</span></code>
(if the <code class="docutils literal notranslate"><span class="pre">PyObject*</span></code> argument is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>).</p>
</div>
<dl class="footnote brackets">
<dt class="label" id="id14"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>,<a href="#id3">3</a>,<a href="#id4">4</a>,<a href="#id5">5</a>,<a href="#id6">6</a>,<a href="#id7">7</a>,<a href="#id8">8</a>,<a href="#id9">9</a>,<a href="#id10">10</a>,<a href="#id11">11</a>,<a href="#id12">12</a>,<a href="#id13">13</a>)</span></dt>
<dd><p>For integer specifiers (d, u, ld, li, lu, lld, lli, llu, zd, zi,
zu, i, x): the 0-conversion flag has effect even when a precision is given.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>增加了对 <code class="docutils literal notranslate"><span class="pre">&quot;%lld&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;%llu&quot;</span></code> 的支持。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了对 <code class="docutils literal notranslate"><span class="pre">&quot;%li&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%lli&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;%zi&quot;</span></code> 的支持。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>增加了对 <code class="docutils literal notranslate"><span class="pre">&quot;%s&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%A&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%U&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%V&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%S&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%R&quot;</span></code> 的宽度和精度格式符支持。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromFormatV">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromFormatV</code><span class="sig-paren">(</span>const char<em> *format</em>, va_list<em> vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromFormatV" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>等同于 <a class="reference internal" href="#c.PyUnicode_FromFormat" title="PyUnicode_FromFormat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromFormat()</span></code></a> 但它将接受恰好两个参数。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromEncodedObject">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromEncodedObject</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em>, const char<em> *encoding</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromEncodedObject" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>将一个已编码的对象 <em>obj</em> 解码为 Unicode 对象。</p>
<p><a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 和其他 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">字节类对象</span></a> 将按照给定的 <em>encoding</em> 来解码并使用由 <em>errors</em> 定义的错误处理方式。 两者均可为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 即让接口使用默认值（请参阅 <a class="reference internal" href="#builtincodecs"><span class="std std-ref">内置编解码器</span></a> 了解详情）。</p>
<p>所有其他对象，包括 Unicode 对象，都将导致设置 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<p>如有错误该 API 将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 调用方要负责递减指向所返回对象的引用。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GetLength">
Py_ssize_t <code class="sig-name descname">PyUnicode_GetLength</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GetLength" title="永久链接至目标">¶</a></dt>
<dd><p>返回 Unicode 对象码位的长度。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_CopyCharacters">
Py_ssize_t <code class="sig-name descname">PyUnicode_CopyCharacters</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *to</em>, Py_ssize_t<em> to_start</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *from</em>, Py_ssize_t<em> from_start</em>, Py_ssize_t<em> how_many</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_CopyCharacters" title="永久链接至目标">¶</a></dt>
<dd><p>Copy characters from one Unicode object into another.  This function performs
character conversion when necessary and falls back to <code class="xref c c-func docutils literal notranslate"><span class="pre">memcpy()</span></code> if
possible.  Returns <code class="docutils literal notranslate"><span class="pre">-1</span></code> and sets an exception on error, otherwise returns
the number of copied characters.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Fill">
Py_ssize_t <code class="sig-name descname">PyUnicode_Fill</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> length</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> fill_char</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Fill" title="永久链接至目标">¶</a></dt>
<dd><p>使用一个字符填充字符串：将 <em>fill_char</em> 写入 <code class="docutils literal notranslate"><span class="pre">unicode[start:start+length]</span></code>。</p>
<p>如果 <em>fill_char</em> 值大于字符串最大字符值，或者如果字符串有 1 以上的引用将执行失败。</p>
<p>返回写入的字符数量，或者在出错时返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 并引发一个异常。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_WriteChar">
int <code class="sig-name descname">PyUnicode_WriteChar</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> index</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> character</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_WriteChar" title="永久链接至目标">¶</a></dt>
<dd><p>将一个字符写入到字符串。 字符串必须通过 <a class="reference internal" href="#c.PyUnicode_New" title="PyUnicode_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_New()</span></code></a> 创建。 由于 Unicode 字符串应当是不可变的，因此该字符串不能被共享，或是被哈希。</p>
<p>该函数将检查 <em>unicode</em> 是否为 Unicode 对象，索引是否未越界，并且对象是否可被安全地修改（即其引用计数为一）。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_ReadChar">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a> <code class="sig-name descname">PyUnicode_ReadChar</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_ReadChar" title="永久链接至目标">¶</a></dt>
<dd><p>Read a character from a string.  This function checks that <em>unicode</em> is a
Unicode object and the index is not out of bounds, in contrast to the macro
version <a class="reference internal" href="#c.PyUnicode_READ_CHAR" title="PyUnicode_READ_CHAR"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READ_CHAR()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Substring">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Substring</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Substring" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>返回 <em>str</em> 的一个子串，从字符索引 <em>start</em> (包括) 到字符索引 <em>end</em> (不包括)。 不支持负索引号。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUCS4">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a>* <code class="sig-name descname">PyUnicode_AsUCS4</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *u</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> *buffer</em>, Py_ssize_t<em> buflen</em>, int<em> copy_null</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUCS4" title="永久链接至目标">¶</a></dt>
<dd><p>将字符串 <em>u</em> 拷贝到一个 UCS4 缓冲区，包括一个空字符，如果设置了 <em>copy_null</em> 的话。 出错时返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 并设置一个异常（特别是当 <em>buflen</em> 小于 <em>u</em> 的长度时，<a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemError</span></code></a> 将被设置）。 成功时返回 <em>buffer</em>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUCS4Copy">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a>* <code class="sig-name descname">PyUnicode_AsUCS4Copy</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *u</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUCS4Copy" title="永久链接至目标">¶</a></dt>
<dd><p>将字符串 <em>u</em> 拷贝到使用 <a class="reference internal" href="memory.html#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a> 分配的新 UCS4 缓冲区。 如果执行失败，将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 并设置 <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a>。 返回的缓冲区将总是会添加一个额外的空码位。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

</section>
<section id="deprecated-py-unicode-apis">
<h3>已弃用的 Py_UNICODE API<a class="headerlink" href="#deprecated-py-unicode-apis" title="永久链接至标题">¶</a></h3>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12.</span></p>
</div>
<p>These API functions are deprecated with the implementation of <span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0393"><strong>PEP 393</strong></a>.
Extension modules can continue using them, as they will not be removed in Python
3.x, but need to be aware that their use can now cause performance and memory hits.</p>
<dl class="function">
<dt id="c.PyUnicode_FromUnicode">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromUnicode</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *u</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromUnicode" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object from the Py_UNICODE buffer <em>u</em> of the given size. <em>u</em>
may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> which causes the contents to be undefined. It is the user's
responsibility to fill in the needed data.  The buffer is copied into the new
object.</p>
<p>If the buffer is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the return value might be a shared object.
Therefore, modification of the resulting Unicode object is only allowed when
<em>u</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>If the buffer is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <a class="reference internal" href="#c.PyUnicode_READY" title="PyUnicode_READY"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READY()</span></code></a> must be called once the
string content has been filled before using any of the access macros such as
<a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_KIND()</span></code></a>.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>Part of the old-style Unicode API, please migrate to using
<a class="reference internal" href="#c.PyUnicode_FromKindAndData" title="PyUnicode_FromKindAndData"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromKindAndData()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_FromWideChar" title="PyUnicode_FromWideChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromWideChar()</span></code></a>, or
<a class="reference internal" href="#c.PyUnicode_New" title="PyUnicode_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_New()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUnicode">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <code class="sig-name descname">PyUnicode_AsUnicode</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUnicode" title="永久链接至目标">¶</a></dt>
<dd><p>Return a read-only pointer to the Unicode object's internal
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error. This will create the
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> representation of the object if it is not yet
available. The buffer is always terminated with an extra null code point.
Note that the resulting <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> string may also contain
embedded null code points, which would cause the string to be truncated when
used in most C functions.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>Part of the old-style Unicode API, please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsUCS4" title="PyUnicode_AsUCS4"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUCS4()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_AsWideChar" title="PyUnicode_AsWideChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsWideChar()</span></code></a>,
<a class="reference internal" href="#c.PyUnicode_ReadChar" title="PyUnicode_ReadChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_ReadChar()</span></code></a> or similar new APIs.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_TransformDecimalToASCII">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_TransformDecimalToASCII</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_TransformDecimalToASCII" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by replacing all decimal digits in
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> by ASCII digits 0--9
according to their decimal value.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception occurs.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.Py_UNICODE_TODECIMAL" title="Py_UNICODE_TODECIMAL"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_UNICODE_TODECIMAL()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUnicodeAndSize">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <code class="sig-name descname">PyUnicode_AsUnicodeAndSize</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> *size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUnicodeAndSize" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#c.PyUnicode_AsUnicode" title="PyUnicode_AsUnicode"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUnicode()</span></code></a>, but also saves the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_UNICODE()</span></code></a>
array length (excluding the extra null terminator) in <em>size</em>.
Note that the resulting <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> string
may contain embedded null code points, which would cause the string to be
truncated when used in most C functions.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>Part of the old-style Unicode API, please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsUCS4" title="PyUnicode_AsUCS4"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUCS4()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_AsWideChar" title="PyUnicode_AsWideChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsWideChar()</span></code></a>,
<a class="reference internal" href="#c.PyUnicode_ReadChar" title="PyUnicode_ReadChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_ReadChar()</span></code></a> or similar new APIs.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUnicodeCopy">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <code class="sig-name descname">PyUnicode_AsUnicodeCopy</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUnicodeCopy" title="永久链接至目标">¶</a></dt>
<dd><p>Create a copy of a Unicode string ending with a null code point. Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
and raise a <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a> exception on memory allocation failure,
otherwise return a new allocated buffer (use <a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> to free
the buffer). Note that the resulting <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> string may
contain embedded null code points, which would cause the string to be
truncated when used in most C functions.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<p>Please migrate to using <a class="reference internal" href="#c.PyUnicode_AsUCS4Copy" title="PyUnicode_AsUCS4Copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUCS4Copy()</span></code></a> or similar new APIs.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GetSize">
Py_ssize_t <code class="sig-name descname">PyUnicode_GetSize</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GetSize" title="永久链接至目标">¶</a></dt>
<dd><p>Return the size of the deprecated <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> representation, in
code units (this includes surrogate pairs as 2 units).</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>旧式 Unicode API 的一部分，请迁移到使用 <a class="reference internal" href="#c.PyUnicode_GET_LENGTH" title="PyUnicode_GET_LENGTH"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_GET_LENGTH()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromObject">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromObject</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromObject" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Copy an instance of a Unicode subtype to a new true Unicode object if
necessary. If <em>obj</em> is already a true Unicode object (not a subtype),
return the reference with incremented refcount.</p>
<p>非 Unicode 或其子类型的对象将导致 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
</dd></dl>

</section>
<section id="locale-encoding">
<h3>语言区域编码格式<a class="headerlink" href="#locale-encoding" title="永久链接至标题">¶</a></h3>
<p>当前语言区域编码格式可被用来解码来自操作系统的文本。</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeLocaleAndSize">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeLocaleAndSize</code><span class="sig-paren">(</span>const char<em> *str</em>, Py_ssize_t<em> len</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeLocaleAndSize" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>解码字符串在 Android 和 VxWorks 上使用 UTF-8，在其他平台上则使用当前语言区域编码格式。 支持的错误处理句柄有 <code class="docutils literal notranslate"><span class="pre">&quot;strict&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;surrogateescape&quot;</span></code> (<span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a>)。 如果 <em>errors</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 则解码器将使用 <code class="docutils literal notranslate"><span class="pre">&quot;strict&quot;</span></code> 错误处理句柄。 <em>str</em> 必须以一个空字符结束但不可包含嵌入的空字符。</p>
<p>Use <a class="reference internal" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="PyUnicode_DecodeFSDefaultAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeFSDefaultAndSize()</span></code></a> to decode a string from
<code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> (the locale encoding read at
Python startup).</p>
<p>This function ignores the Python UTF-8 mode.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>The <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 函数。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>此函数现在也会为 <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> 错误处理句柄使用当前语言区域编码格式，但在 Android 上例外。 在之前版本中，<a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 将被用于 <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code>，而当前语言区域编码格式将被用于 <code class="docutils literal notranslate"><span class="pre">strict</span></code>。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeLocale">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeLocale</code><span class="sig-paren">(</span>const char<em> *str</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeLocale" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Similar to <a class="reference internal" href="#c.PyUnicode_DecodeLocaleAndSize" title="PyUnicode_DecodeLocaleAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeLocaleAndSize()</span></code></a>, but compute the string
length using <code class="xref c c-func docutils literal notranslate"><span class="pre">strlen()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeLocale">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeLocale</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeLocale" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>编码 Unicode 对象在 Android 和 VxWorks 上使用 UTF-8，在其他平台上使用当前语言区域编码格式。 支持的错误处理句柄有 <code class="docutils literal notranslate"><span class="pre">&quot;strict&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;surrogateescape&quot;</span></code> (<span class="target" id="index-12"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a>)。 如果 <em>errors</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 则编码器将使用 <code class="docutils literal notranslate"><span class="pre">&quot;strict&quot;</span></code> 错误处理句柄。 返回一个 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象。 <em>unicode</em> 不可包含嵌入的空字符。</p>
<p>Use <a class="reference internal" href="#c.PyUnicode_EncodeFSDefault" title="PyUnicode_EncodeFSDefault"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeFSDefault()</span></code></a> to encode a string to
<code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> (the locale encoding read at
Python startup).</p>
<p>This function ignores the Python UTF-8 mode.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EncodeLocale()</span></code></a> 函数。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>此函数现在也会为 <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> 错误处理句柄使用当前语言区域编码格式，但在 Android 上例外。 在之前版本中，<a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EncodeLocale()</span></code></a> 将被用于 <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code>，而当前语言区域编码格式将被用于 <code class="docutils literal notranslate"><span class="pre">strict</span></code>。</p>
</div>
</dd></dl>

</section>
<section id="file-system-encoding">
<h3>文件系统编码格式<a class="headerlink" href="#file-system-encoding" title="永久链接至标题">¶</a></h3>
<p>To encode and decode file names and other environment strings,
<code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> should be used as the encoding, and
<code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> should be used as the error handler
(<span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a> and <span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0529"><strong>PEP 529</strong></a>). To encode file names to <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> during
argument parsing, the <code class="docutils literal notranslate"><span class="pre">&quot;O&amp;&quot;</span></code> converter should be used, passing
<a class="reference internal" href="#c.PyUnicode_FSConverter" title="PyUnicode_FSConverter"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FSConverter()</span></code></a> as the conversion function:</p>
<dl class="function">
<dt id="c.PyUnicode_FSConverter">
int <code class="sig-name descname">PyUnicode_FSConverter</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>*<em> obj</em>, void*<em> result</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FSConverter" title="永久链接至目标">¶</a></dt>
<dd><p>ParseTuple converter: encode <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> objects -- obtained directly or
through the <a class="reference internal" href="../library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> interface -- to <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> using
<a class="reference internal" href="#c.PyUnicode_EncodeFSDefault" title="PyUnicode_EncodeFSDefault"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeFSDefault()</span></code></a>; <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> objects are output as-is.
<em>result</em> must be a <a class="reference internal" href="bytes.html#c.PyBytesObject" title="PyBytesObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBytesObject*</span></code></a> which must be released when it is
no longer used.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>接受一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>。</p>
</div>
</dd></dl>

<p>要在参数解析期间将文件名解码为 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>，应当使用 <code class="docutils literal notranslate"><span class="pre">&quot;O&amp;&quot;</span></code> 转换器，传入 <a class="reference internal" href="#c.PyUnicode_FSDecoder" title="PyUnicode_FSDecoder"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FSDecoder()</span></code></a> 作为转换函数：</p>
<dl class="function">
<dt id="c.PyUnicode_FSDecoder">
int <code class="sig-name descname">PyUnicode_FSDecoder</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>*<em> obj</em>, void*<em> result</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FSDecoder" title="永久链接至目标">¶</a></dt>
<dd><p>ParseTuple converter: decode <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> objects -- obtained either
directly or indirectly through the <a class="reference internal" href="../library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> interface -- to
<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> using <a class="reference internal" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="PyUnicode_DecodeFSDefaultAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeFSDefaultAndSize()</span></code></a>; <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>
objects are output as-is. <em>result</em> must be a <a class="reference internal" href="#c.PyUnicodeObject" title="PyUnicodeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyUnicodeObject*</span></code></a> which
must be released when it is no longer used.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>接受一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeFSDefaultAndSize">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeFSDefaultAndSize</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Decode a string using <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> and the
<code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> error handler.</p>
<p>If <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> is not set, fall back to the
locale encoding.</p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> is initialized at startup from the
locale encoding and cannot be modified later. If you need to decode a string
from the current locale encoding, use
<a class="reference internal" href="#c.PyUnicode_DecodeLocaleAndSize" title="PyUnicode_DecodeLocaleAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeLocaleAndSize()</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>The <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 函数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>Use <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> error handler.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeFSDefault">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeFSDefault</code><span class="sig-paren">(</span>const char<em> *s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeFSDefault" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Decode a null-terminated string using <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code>
and the <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> error handler.</p>
<p>If <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> is not set, fall back to the
locale encoding.</p>
<p>Use <a class="reference internal" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="PyUnicode_DecodeFSDefaultAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeFSDefaultAndSize()</span></code></a> if you know the string length.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>Use <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> error handler.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeFSDefault">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeFSDefault</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeFSDefault" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object to <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> with the
<code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> error handler, and return
<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Note that the resulting <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> object may contain
null bytes.</p>
<p>If <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> is not set, fall back to the
locale encoding.</p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> is initialized at startup from the
locale encoding and cannot be modified later. If you need to encode a string
to the current locale encoding, use <a class="reference internal" href="#c.PyUnicode_EncodeLocale" title="PyUnicode_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeLocale()</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EncodeLocale()</span></code></a> 函数。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>Use <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> error handler.</p>
</div>
</dd></dl>

</section>
<section id="wchar-t-support">
<h3>wchar_t 支持<a class="headerlink" href="#wchar-t-support" title="永久链接至标题">¶</a></h3>
<p>在受支持的平台上支持 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code>:</p>
<dl class="function">
<dt id="c.PyUnicode_FromWideChar">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromWideChar</code><span class="sig-paren">(</span>const wchar_t<em> *w</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromWideChar" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>根据给定 <em>size</em> 的 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> 缓冲区 <em>w</em> 创建一个 Unicode 对象。 传入 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 作为 <em>size</em> 表示该函数必须使用 wcslen 自行计算缓冲区长度。 失败时将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsWideChar">
Py_ssize_t <code class="sig-name descname">PyUnicode_AsWideChar</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, wchar_t<em> *w</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsWideChar" title="永久链接至目标">¶</a></dt>
<dd><p>Copy the Unicode object contents into the <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> buffer <em>w</em>.  At most
<em>size</em> <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> characters are copied (excluding a possibly trailing
null termination character).  Return the number of <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> characters
copied or <code class="docutils literal notranslate"><span class="pre">-1</span></code> in case of an error.  Note that the resulting <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code>
string may or may not be null-terminated.  It is the responsibility of the caller
to make sure that the <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code> string is null-terminated in case this is
required by the application. Also, note that the <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code> string
might contain null characters, which would cause the string to be truncated
when used with most C functions.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsWideCharString">
wchar_t* <code class="sig-name descname">PyUnicode_AsWideCharString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> *size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsWideCharString" title="永久链接至目标">¶</a></dt>
<dd><p>Convert the Unicode object to a wide character string. The output string
always ends with a null character. If <em>size</em> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, write the number
of wide characters (excluding the trailing null termination character) into
<em>*size</em>. Note that the resulting <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> string might contain
null characters, which would cause the string to be truncated when used with
most C functions. If <em>size</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code> string
contains null characters a <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised.</p>
<p>Returns a buffer allocated by <code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Alloc()</span></code> (use
<a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> to free it) on success. On error, returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
and <em>*size</em> is undefined. Raises a <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a> if memory allocation
is failed.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>Raises a <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> if <em>size</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code>
string contains null characters.</p>
</div>
</dd></dl>

</section>
</section>
<section id="built-in-codecs">
<span id="builtincodecs"></span><h2>内置编解码器<a class="headerlink" href="#built-in-codecs" title="永久链接至标题">¶</a></h2>
<p>Python 提供了一组以 C 编写以保证运行速度的内置编解码器。 所有这些编解码器均可通过下列函数直接使用。</p>
<p>下列 API 大都接受 encoding 和 errors 两个参数，它们具有与在内置 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 字符串对象构造器中同名参数相同的语义。</p>
<p>Setting encoding to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> causes the default encoding to be used
which is ASCII.  The file system calls should use
<a class="reference internal" href="#c.PyUnicode_FSConverter" title="PyUnicode_FSConverter"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FSConverter()</span></code></a> for encoding file names. This uses the
variable <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> internally. This
variable should be treated as read-only: on some systems, it will be a
pointer to a static string, on others, it will change at run-time
(such as when the application invokes setlocale).</p>
<p>错误处理方式由 errors 设置并且也可以设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 表示使用为编解码器定义的默认处理方式。 所有内置编解码器的默认错误处理方式是 &quot;strict&quot; (会引发 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>)。</p>
<p>The codecs all use a similar interface.  Only deviation from the following
generic ones are documented for simplicity.</p>
<section id="generic-codecs">
<h3>泛型编解码器<a class="headerlink" href="#generic-codecs" title="永久链接至标题">¶</a></h3>
<p>以下是泛型编解码器的 API:</p>
<dl class="function">
<dt id="c.PyUnicode_Decode">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Decode</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *encoding</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Decode" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>通过解码已编码字符串 <em>s</em> 的 <em>size</em> 个字节创建一个 Unicode 对象。 <em>encoding</em> 和 <em>errors</em> 具有与 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 内置函数中同名形参相同的含义。 要使用的编解码器将使用 Python 编解码器注册表来查找。 如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsEncodedString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsEncodedString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, const char<em> *encoding</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsEncodedString" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>编码一个 Unicode 对象并将结果作为 Python 字节串对象返回。 <em>encoding</em> 和 <em>errors</em> 具有与 Unicode <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a> 方法中同名形参相同的含义。 要使用的编解码器将使用 Python 编解码器注册表来查找。 如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Encode">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Encode</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *encoding</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Encode" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer <em>s</em> of the given <em>size</em> and return a Python
bytes object.  <em>encoding</em> and <em>errors</em> have the same meaning as the
parameters of the same name in the Unicode <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a> method.  The codec
to be used is looked up using the Python codec registry.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an
exception was raised by the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="utf-8-codecs">
<h3>UTF-8 编解码器<a class="headerlink" href="#utf-8-codecs" title="永久链接至标题">¶</a></h3>
<p>以下是 UTF-8 编解码器 API:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUTF8">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF8</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF8" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>通过解码 UTF-8 编码的字节串 <em>s</em> 的 <em>size</em> 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeUTF8Stateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF8Stateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF8Stateful" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>如果 <em>consumed</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则行为类似于 <a class="reference internal" href="#c.PyUnicode_DecodeUTF8" title="PyUnicode_DecodeUTF8"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF8()</span></code></a>。 如果 <em>consumed</em> 不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则末尾的不完整 UTF-8 字节序列将不被视为错误。 这些字节将不会被解码并且已被解码的字节数将存储在 <em>consumed</em> 中。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF8String">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsUTF8String</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF8String" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>使用 UTF-8 编码 Unicode 对象并将结果作为 Python 字节串对象返回。 错误处理方式为 &quot;strict&quot;。 如果编解码器引发了异常则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF8AndSize">
const char* <code class="sig-name descname">PyUnicode_AsUTF8AndSize</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> *size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF8AndSize" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个指向 Unicode 对象的 UTF-8 编码格式数据的指针，并将已编码数据的大小（以字节为单位）存储在 <em>size</em> 中。 <em>size</em> 参数可以为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>；在此情况下数据的大小将不会被存储。 返回的缓冲区总是会添加一个额外的空字节（不包括在 <em>size</em> 中），无论是否存在任何其他的空码位。</p>
<p>在发生错误的情况下，将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 附带设置一个异常并且不会存储 <em>size</em> 值。</p>
<p>This caches the UTF-8 representation of the string in the Unicode object, and
subsequent calls will return a pointer to the same buffer.  The caller is not
responsible for deallocating the buffer.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>返回类型现在是 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF8">
const char* <code class="sig-name descname">PyUnicode_AsUTF8</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF8" title="永久链接至目标">¶</a></dt>
<dd><p>类似于 <a class="reference internal" href="#c.PyUnicode_AsUTF8AndSize" title="PyUnicode_AsUTF8AndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF8AndSize()</span></code></a>，但不会存储大小值。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>返回类型现在是 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUTF8">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUTF8</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUTF8" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer <em>s</em> of the given <em>size</em> using UTF-8 and
return a Python bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by
the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsUTF8String" title="PyUnicode_AsUTF8String"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF8String()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_AsUTF8AndSize" title="PyUnicode_AsUTF8AndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF8AndSize()</span></code></a> or
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="utf-32-codecs">
<h3>UTF-32 编解码器<a class="headerlink" href="#utf-32-codecs" title="永久链接至标题">¶</a></h3>
<p>以下是 UTF-32 编解码器 API:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUTF32">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF32</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> *byteorder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF32" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>从 UTF-32 编码的缓冲区数据解码 <em>size</em> 个字节并返回相应的 Unicode 对象。 <em>errors</em> (如果不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>) 定义了错误处理方式。 默认为 &quot;strict&quot;。</p>
<p>如果 <em>byteorder</em> 不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，解码器将使用给定的字节序进行解码:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="n">byteorder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="o">:</span><span class="w"> </span><span class="n">little</span><span class="w"> </span><span class="n">endian</span>
<span class="o">*</span><span class="n">byteorder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="o">:</span><span class="w">  </span><span class="n">native</span><span class="w"> </span><span class="n">order</span>
<span class="o">*</span><span class="n">byteorder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w">  </span><span class="n">big</span><span class="w"> </span><span class="n">endian</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal notranslate"><span class="pre">*byteorder</span></code> 为零，且输入数据的前四个字节为字节序标记 (BOM)，则解码器将切换为该字节序并且 BOM 将不会被拷贝到结果 Unicode 字符串中。 如果 <code class="docutils literal notranslate"><span class="pre">*byteorder</span></code> 为 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">1</span></code>，则字节序标记会被拷贝到输出中。</p>
<p>在完成后，<em>*byteorder</em> 将在输入数据的末尾被设为当前字节序。</p>
<p>如果 <em>byteorder</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，编解码器将使用本机字节序。</p>
<p>如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeUTF32Stateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF32Stateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> *byteorder</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF32Stateful" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>如果 <em>consumed</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则行为类似于 <a class="reference internal" href="#c.PyUnicode_DecodeUTF32" title="PyUnicode_DecodeUTF32"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF32()</span></code></a>。 如果 <em>consumed</em> 不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则 <a class="reference internal" href="#c.PyUnicode_DecodeUTF32Stateful" title="PyUnicode_DecodeUTF32Stateful"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF32Stateful()</span></code></a> 将不把末尾的不完整 UTF-32 字节序列（如字节数不可被四整除）视为错误。 这些字节将不会被解码并且已被解码的字节数将存储在 <em>consumed</em> 中。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF32String">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsUTF32String</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF32String" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>返回使用 UTF-32 编码格式本机字节序的 Python 字节串。 字节串将总是以 BOM 标记打头。 错误处理方式为 &quot;strict&quot;。 如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUTF32">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUTF32</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> byteorder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUTF32" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Return a Python bytes object holding the UTF-32 encoded value of the Unicode
data in <em>s</em>.  Output is written according to the following byte order:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">byteorder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="o">:</span><span class="w"> </span><span class="n">little</span><span class="w"> </span><span class="n">endian</span>
<span class="n">byteorder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="o">:</span><span class="w">  </span><span class="n">native</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="p">(</span><span class="n">writes</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">BOM</span><span class="w"> </span><span class="n">mark</span><span class="p">)</span>
<span class="n">byteorder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w">  </span><span class="n">big</span><span class="w"> </span><span class="n">endian</span>
</pre></div>
</div>
<p>If byteorder is <code class="docutils literal notranslate"><span class="pre">0</span></code>, the output string will always start with the Unicode BOM
mark (U+FEFF). In the other two modes, no BOM mark is prepended.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Py_UNICODE_WIDE</span></code> is not defined, surrogate pairs will be output
as a single code point.</p>
<p>如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsUTF32String" title="PyUnicode_AsUTF32String"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF32String()</span></code></a> or <a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="utf-16-codecs">
<h3>UTF-16 编解码器<a class="headerlink" href="#utf-16-codecs" title="永久链接至标题">¶</a></h3>
<p>以下是 UTF-16 编解码器的 API:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUTF16">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF16</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> *byteorder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF16" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>从 UTF-16 编码的缓冲区数据解码 <em>size</em> 个字节并返回相应的 Unicode 对象。 <em>errors</em> (如果不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>) 定义了错误处理方式。 默认为 &quot;strict&quot;。</p>
<p>如果 <em>byteorder</em> 不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，解码器将使用给定的字节序进行解码:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="n">byteorder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="o">:</span><span class="w"> </span><span class="n">little</span><span class="w"> </span><span class="n">endian</span>
<span class="o">*</span><span class="n">byteorder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="o">:</span><span class="w">  </span><span class="n">native</span><span class="w"> </span><span class="n">order</span>
<span class="o">*</span><span class="n">byteorder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w">  </span><span class="n">big</span><span class="w"> </span><span class="n">endian</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal notranslate"><span class="pre">*byteorder</span></code> 为零，且输入数据的前两个字节为字节序标记 (BOM)，则解码器将切换为该字节序并且 BOM 将不会被拷贝到结果 Unicode 字符串中。 如果 <code class="docutils literal notranslate"><span class="pre">*byteorder</span></code> 为 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">1</span></code>，则字节序标记会被拷贝到输出中 (它将是一个 <code class="docutils literal notranslate"><span class="pre">\ufeff</span></code> 或 <code class="docutils literal notranslate"><span class="pre">\ufffe</span></code> 字符)。</p>
<p>在完成后，<em>*byteorder</em> 将在输入数据的末尾被设为当前字节序。</p>
<p>如果 <em>byteorder</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，编解码器将使用本机字节序。</p>
<p>如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeUTF16Stateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF16Stateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> *byteorder</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF16Stateful" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>如果 <em>consumed</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则行为类似于 <a class="reference internal" href="#c.PyUnicode_DecodeUTF16" title="PyUnicode_DecodeUTF16"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF16()</span></code></a>。 如果 <em>consumed</em> 不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则 <a class="reference internal" href="#c.PyUnicode_DecodeUTF16Stateful" title="PyUnicode_DecodeUTF16Stateful"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF16Stateful()</span></code></a> 将不把末尾的不完整 UTF-16 字节序列（如为奇数个字节或为分开的替代对）视为错误。 这些字节将不会被解码并且已被解码的字节数将存储在 <em>consumed</em> 中。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF16String">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsUTF16String</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF16String" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>返回使用 UTF-16 编码格式本机字节序的 Python 字节串。 字节串将总是以 BOM 标记打头。 错误处理方式为 &quot;strict&quot;。 如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUTF16">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUTF16</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> byteorder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUTF16" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Return a Python bytes object holding the UTF-16 encoded value of the Unicode
data in <em>s</em>.  Output is written according to the following byte order:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">byteorder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="o">:</span><span class="w"> </span><span class="n">little</span><span class="w"> </span><span class="n">endian</span>
<span class="n">byteorder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="o">:</span><span class="w">  </span><span class="n">native</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="p">(</span><span class="n">writes</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">BOM</span><span class="w"> </span><span class="n">mark</span><span class="p">)</span>
<span class="n">byteorder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w">  </span><span class="n">big</span><span class="w"> </span><span class="n">endian</span>
</pre></div>
</div>
<p>If byteorder is <code class="docutils literal notranslate"><span class="pre">0</span></code>, the output string will always start with the Unicode BOM
mark (U+FEFF). In the other two modes, no BOM mark is prepended.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Py_UNICODE_WIDE</span></code> is defined, a single <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> value may get
represented as a surrogate pair. If it is not defined, each <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a>
values is interpreted as a UCS-2 character.</p>
<p>如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsUTF16String" title="PyUnicode_AsUTF16String"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF16String()</span></code></a> or <a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="utf-7-codecs">
<h3>UTF-7 编解码器<a class="headerlink" href="#utf-7-codecs" title="永久链接至标题">¶</a></h3>
<p>以下是 UTF-7 编解码器 API:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUTF7">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF7</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF7" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>通过解码 UTF-7 编码的字节串 <em>s</em> 的 <em>size</em> 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeUTF7Stateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF7Stateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF7Stateful" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>如果 <em>consumed</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则行为类似于 <a class="reference internal" href="#c.PyUnicode_DecodeUTF7" title="PyUnicode_DecodeUTF7"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF7()</span></code></a>。 如果 <em>consumed</em> 不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则末尾的不完整 UTF-7 base-64 部分将不被视为错误。 这些字节将不会被解码并且已被解码的字节数将存储在 <em>consumed</em> 中。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUTF7">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUTF7</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, int<em> base64SetO</em>, int<em> base64WhiteSpace</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUTF7" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given size using UTF-7 and
return a Python bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by
the codec.</p>
<p>If <em>base64SetO</em> is nonzero, &quot;Set O&quot; (punctuation that has no otherwise
special meaning) will be encoded in base-64.  If <em>base64WhiteSpace</em> is
nonzero, whitespace will be encoded in base-64.  Both are set to zero for the
Python &quot;utf-7&quot; codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="unicode-escape-codecs">
<h3>Unicode-Escape 编解码器<a class="headerlink" href="#unicode-escape-codecs" title="永久链接至标题">¶</a></h3>
<p>以下是 &quot;Unicode Escape&quot; 编解码器的 API:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUnicodeEscape">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUnicodeEscape</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUnicodeEscape" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>通过解码 Unicode-Escape 编码的字节串 <em>s</em> 的 <em>size</em> 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUnicodeEscapeString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsUnicodeEscapeString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUnicodeEscapeString" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>使用 Unicode-Escape 编码 Unicode 对象并将结果作为字节串对象返回。 错误处理方式为 &quot;strict&quot;。 如果编解码器引发了异常则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUnicodeEscape">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUnicodeEscape</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUnicodeEscape" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> using Unicode-Escape and
return a bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsUnicodeEscapeString" title="PyUnicode_AsUnicodeEscapeString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUnicodeEscapeString()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="raw-unicode-escape-codecs">
<h3>Raw-Unicode-Escape 编解码器<a class="headerlink" href="#raw-unicode-escape-codecs" title="永久链接至标题">¶</a></h3>
<p>以下是 &quot;Raw Unicode Escape&quot; 编解码器的 API:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeRawUnicodeEscape">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeRawUnicodeEscape</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeRawUnicodeEscape" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>通过解码 Raw-Unicode-Escape 编码的字节串 <em>s</em> 的 <em>size</em> 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsRawUnicodeEscapeString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsRawUnicodeEscapeString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsRawUnicodeEscapeString" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>使用 Raw-Unicode-Escape 编码 Unicode 对象并将结果作为字节串对象返回。 错误处理方式为 &quot;strict&quot;。 如果编解码器引发了异常则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeRawUnicodeEscape">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeRawUnicodeEscape</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeRawUnicodeEscape" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> using Raw-Unicode-Escape
and return a bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsRawUnicodeEscapeString" title="PyUnicode_AsRawUnicodeEscapeString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsRawUnicodeEscapeString()</span></code></a> or
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="latin-1-codecs">
<h3>Latin-1 编解码器<a class="headerlink" href="#latin-1-codecs" title="永久链接至标题">¶</a></h3>
<p>以下是 Latin-1 编解码器的 API: Latin-1 对应于前 256 个 Unicode 码位且编码器在编码期间只接受这些码位。</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeLatin1">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeLatin1</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeLatin1" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>通过解码 Latin-1 编码的字节串 <em>s</em> 的 <em>size</em> 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsLatin1String">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsLatin1String</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsLatin1String" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>使用 Latin-1 编码 Unicode 对象并将结果作为 Python 字节串对象返回。 错误处理方式为 &quot;strict&quot;。 如果编解码器引发了异常则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeLatin1">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeLatin1</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeLatin1" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> using Latin-1 and
return a Python bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by
the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsLatin1String" title="PyUnicode_AsLatin1String"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsLatin1String()</span></code></a> or
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="ascii-codecs">
<h3>ASCII 编解码器<a class="headerlink" href="#ascii-codecs" title="永久链接至标题">¶</a></h3>
<p>以下是 ASCII 编解码器的 API。 只接受 7 位 ASCII 数据。 任何其他编码的数据都将导致错误。</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeASCII">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeASCII</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeASCII" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>通过解码 ASCII 编码的字节串 <em>s</em> 的 <em>size</em> 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsASCIIString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsASCIIString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsASCIIString" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>使用 ASCII 编码 Unicode 对象并将结果作为 Python 字节串对象返回。 错误处理方式为 &quot;strict&quot;。 如果编解码器引发了异常则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeASCII">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeASCII</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeASCII" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> using ASCII and
return a Python bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by
the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsASCIIString" title="PyUnicode_AsASCIIString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsASCIIString()</span></code></a> or
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="character-map-codecs">
<h3>字符映射编解码器<a class="headerlink" href="#character-map-codecs" title="永久链接至标题">¶</a></h3>
<p>This codec is special in that it can be used to implement many different codecs
(and this is in fact what was done to obtain most of the standard codecs
included in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings</span></code> package). The codec uses mapping to encode and
decode characters.  The mapping objects provided must support the
<a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> mapping interface; dictionaries and sequences work well.</p>
<p>以下是映射编解码器的 API:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeCharmap">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeCharmap</code><span class="sig-paren">(</span>const char<em> *data</em>, Py_ssize_t<em> size</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *mapping</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeCharmap" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>通过使用给定的 <em>mapping</em> 对象解码已编码字节串 <em>s</em> 的 <em>size</em> 个字节创建 Unicode 对象。 如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>如果 <em>mapping</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则将应用 Latin-1 编码格式。 否则 <em>mapping</em> 必须为字节码位值（0 至 255 范围内的整数）到 Unicode 字符串的映射、整数（将被解读为 Unicode 码位）或 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 未映射的数据字节 -- 这样的数据将导致 <a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>，以及被映射到 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的数据，<code class="docutils literal notranslate"><span class="pre">0xFFFE</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'\ufffe'</span></code>，将被视为未定义的映射并导致报错。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsCharmapString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsCharmapString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsCharmapString" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>使用给定的 <em>mapping</em> 对象编码 Unicode 对象并将结果作为字节串对象返回。 错误处理方式为 &quot;strict&quot;。 如果编解码器引发了异常则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p><em>mapping</em> 对象必须将整数 Unicode 码位映射到字节串对象、0 至 255 范围内的整数或 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 未映射的字符码位（将导致 <a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> 的数据）以及映射到 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的数据将被视为“未定义的映射”并导致报错。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeCharmap">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeCharmap</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *mapping</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeCharmap" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> using the given
<em>mapping</em> object and return the result as a bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if
an exception was raised by the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsCharmapString" title="PyUnicode_AsCharmapString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsCharmapString()</span></code></a> or
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

<p>以下特殊的编解码器 API 会将 Unicode 映射至 Unicode。</p>
<dl class="function">
<dt id="c.PyUnicode_Translate">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Translate</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *table</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Translate" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>通过应用字符映射表来转写字符串并返回结果 Unicode 对象。 如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>字符映射表必须将整数 Unicode 码位映射到整数 Unicode 码位或 <code class="docutils literal notranslate"><span class="pre">None</span></code> (这将删除相应的字符)。</p>
<p>Mapping tables need only provide the <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> interface; dictionaries
and sequences work well.  Unmapped character ordinals (ones which cause a
<a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>) are left untouched and are copied as-is.</p>
<p><em>errors</em> 具有用于编解码器的通常含义。 它可以为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 表示使用默认的错误处理方式。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_TranslateCharmap">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_TranslateCharmap</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *mapping</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_TranslateCharmap" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Translate a <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> by applying a
character <em>mapping</em> table to it and return the resulting Unicode object.
Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> when an exception was raised by the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_Translate" title="PyUnicode_Translate"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_Translate()</span></code></a>. or <a class="reference internal" href="codec.html#codec-registry"><span class="std std-ref">generic codec based API</span></a></p>
</div>
</dd></dl>

</section>
<section id="mbcs-codecs-for-windows">
<h3>Windows 中的 MBCS 编解码器<a class="headerlink" href="#mbcs-codecs-for-windows" title="永久链接至标题">¶</a></h3>
<p>以下是 MBCS 编解码器的 API。 目前它们仅在 Windows 中可用并使用 Win32 MBCS 转换器来实现转换。 请注意 MBCS（或 DBCS）是一类编码格式，而非只有一个。 目标编码格式是由运行编解码器的机器上的用户设置定义的。</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeMBCS">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeMBCS</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeMBCS" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>通过解码 MBCS 编码的字节串 <em>s</em> 的 <em>size</em> 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeMBCSStateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeMBCSStateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeMBCSStateful" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>如果 <em>consumed</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则行为类似于 <a class="reference internal" href="#c.PyUnicode_DecodeMBCS" title="PyUnicode_DecodeMBCS"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeMBCS()</span></code></a>。 如果 <em>consumed</em> 不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则 <a class="reference internal" href="#c.PyUnicode_DecodeMBCSStateful" title="PyUnicode_DecodeMBCSStateful"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeMBCSStateful()</span></code></a> 将不会解码末尾的不完整字节并且已被解码的字节数将存储在 <em>consumed</em> 中。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsMBCSString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsMBCSString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsMBCSString" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>使用 MBCS 编码 Unicode 对象并将结果作为 Python 字节串对象返回。 错误处理方式为 &quot;strict&quot;。 如果编解码器引发了异常则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeCodePage">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeCodePage</code><span class="sig-paren">(</span>int<em> code_page</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeCodePage" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the Unicode object using the specified code page and return a Python
bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec. Use
<code class="xref c c-data docutils literal notranslate"><span class="pre">CP_ACP</span></code> code page to get the MBCS encoder.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeMBCS">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeMBCS</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeMBCS" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> using MBCS and return
a Python bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the
codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsMBCSString" title="PyUnicode_AsMBCSString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsMBCSString()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_EncodeCodePage" title="PyUnicode_EncodeCodePage"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeCodePage()</span></code></a> or
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="methods-slots">
<h3>方法和槽位<a class="headerlink" href="#methods-slots" title="永久链接至标题">¶</a></h3>
</section>
</section>
<section id="methods-and-slot-functions">
<span id="unicodemethodsandslots"></span><h2>方法与槽位函数<a class="headerlink" href="#methods-and-slot-functions" title="永久链接至标题">¶</a></h2>
<p>以下 API 可以处理输入的 Unicode 对象和字符串（在描述中我们称其为字符串）并返回适当的 Unicode 对象或整数值。</p>
<p>如果发生异常它们都将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p>
<dl class="function">
<dt id="c.PyUnicode_Concat">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Concat</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *left</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *right</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Concat" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>拼接两个字符串得到一个新的 Unicode 字符串。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Split">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Split</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *s</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *sep</em>, Py_ssize_t<em> maxsplit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Split" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>拆分一个字符串得到一个 Unicode 字符串的列表。 如果 <em>sep</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则将根据空格来拆分所有子字符串。 否则，将根据指定的分隔符来拆分。 最多拆分数为 <em>maxsplit</em>。 如为负值，则没有限制。 分隔符不包括在结果列表中。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Splitlines">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Splitlines</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *s</em>, int<em> keepend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Splitlines" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Split a Unicode string at line breaks, returning a list of Unicode strings.
CRLF is considered to be one line break.  If <em>keepend</em> is <code class="docutils literal notranslate"><span class="pre">0</span></code>, the Line break
characters are not included in the resulting strings.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Join">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Join</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *separator</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *seq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Join" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>使用给定的 <em>separator</em> 合并一个字符串列表并返回结果 Unicode 字符串。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Tailmatch">
Py_ssize_t <code class="sig-name descname">PyUnicode_Tailmatch</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *substr</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em>, int<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Tailmatch" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>substr</em> 在给定的端点 (<em>direction</em> == <code class="docutils literal notranslate"><span class="pre">-1</span></code> 表示前缀匹配，<em>direction</em> == <code class="docutils literal notranslate"><span class="pre">1</span></code> 表示后缀匹配) 与 <code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code> 相匹配则返回 <code class="docutils literal notranslate"><span class="pre">1</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>。 如果发生错误则返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Find">
Py_ssize_t <code class="sig-name descname">PyUnicode_Find</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *substr</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em>, int<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Find" title="永久链接至目标">¶</a></dt>
<dd><p>返回使用给定的 <em>direction</em> (<em>direction</em> == <code class="docutils literal notranslate"><span class="pre">1</span></code> 表示前向搜索，<em>direction</em> == <code class="docutils literal notranslate"><span class="pre">-1</span></code> 表示后向搜索) 时 <em>substr</em> 在 <code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code> 中首次出现的位置。 返回值为首个匹配的索引号；值为 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 表示未找到匹配，<code class="docutils literal notranslate"><span class="pre">-2</span></code> 则表示发生错误并设置了异常。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FindChar">
Py_ssize_t <code class="sig-name descname">PyUnicode_FindChar</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> ch</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em>, int<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FindChar" title="永久链接至目标">¶</a></dt>
<dd><p>返回使用给定的 <em>direction</em> (<em>direction</em> == <code class="docutils literal notranslate"><span class="pre">1</span></code> 表示前向搜索，<em>direction</em> == <code class="docutils literal notranslate"><span class="pre">-1</span></code> 表示后向搜索) 时字符 <em>ch</em> 在 <code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code> 中首次出现的位置。 返回值为首个匹配的索引号；值为 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 表示未找到匹配，<code class="docutils literal notranslate"><span class="pre">-2</span></code> 则表示发生错误并设置了异常。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>现在 <em>start</em> 和 <em>end</em> 被调整为与 <code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code> 类似的行为。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Count">
Py_ssize_t <code class="sig-name descname">PyUnicode_Count</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *substr</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Count" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>substr</em> 在 <code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code> 中不重叠出现的次数。 如果发生错误则返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Replace">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Replace</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *substr</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *replstr</em>, Py_ssize_t<em> maxcount</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Replace" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>将 <em>str</em> 中 <em>substr</em> 在替换为 <em>replstr</em> 至多 <em>maxcount</em> 次并返回结果 Unicode 对象。 <em>maxcount</em> == <code class="docutils literal notranslate"><span class="pre">-1</span></code> 表示全部替换。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Compare">
int <code class="sig-name descname">PyUnicode_Compare</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *left</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *right</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Compare" title="永久链接至目标">¶</a></dt>
<dd><p>比较两个字符串并返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code> 分别表示小于、等于和大于。</p>
<p>此函数执行失败时返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>，因此应当调用 <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_Occurred()</span></code></a> 来检查错误。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_CompareWithASCIIString">
int <code class="sig-name descname">PyUnicode_CompareWithASCIIString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *uni</em>, const char<em> *string</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_CompareWithASCIIString" title="永久链接至目标">¶</a></dt>
<dd><p>将 Unicode 对象 <em>uni</em> 与 <em>string</em> 进行比较并返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code> 分别表示小于、等于和大于。 最好只传入 ASCII 编码的字符串，但如果输入字符串包含非 ASCII 字符则此函数会将其按 ISO-8859-1 编码来解读。</p>
<p>此函数不会引发异常。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_RichCompare">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_RichCompare</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *left</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *right</em>, int<em> op</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_RichCompare" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>对两个 Unicode 字符串执行富比较并返回以下值之一:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> 用于引发了异常的情况</p></li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_True</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_False</span></code> for successful comparisons</p></li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code> in case the type combination is unknown</p></li>
</ul>
<p>Possible values for <em>op</em> are <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_GT</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_GE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_EQ</span></code>,
<code class="xref py py-const docutils literal notranslate"><span class="pre">Py_NE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_LT</span></code>, and <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_LE</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Format">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Format</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *format</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Format" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>根据 <em>format</em> 和 <em>args</em> 返回一个新的字符串对象；这等同于 <code class="docutils literal notranslate"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">args</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Contains">
int <code class="sig-name descname">PyUnicode_Contains</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *container</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *element</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Contains" title="永久链接至目标">¶</a></dt>
<dd><p>检查 <em>element</em> 是否包含在 <em>container</em> 中并相应返回真值或假值。</p>
<p><em>element</em> 必须强制转成一个单元素 Unicode 字符串。 如果发生错误则返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_InternInPlace">
void <code class="sig-name descname">PyUnicode_InternInPlace</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> **string</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_InternInPlace" title="永久链接至目标">¶</a></dt>
<dd><p>Intern the argument <em>*string</em> in place.  The argument must be the address of a
pointer variable pointing to a Python Unicode string object.  If there is an
existing interned string that is the same as <em>*string</em>, it sets <em>*string</em> to
it (decrementing the reference count of the old string object and incrementing
the reference count of the interned string object), otherwise it leaves
<em>*string</em> alone and interns it (incrementing its reference count).
(Clarification: even though there is a lot of talk about reference counts, think
of this function as reference-count-neutral; you own the object after the call
if and only if you owned it before the call.)</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_InternFromString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_InternFromString</code><span class="sig-paren">(</span>const char<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_InternFromString" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><a class="reference internal" href="#c.PyUnicode_FromString" title="PyUnicode_FromString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromString()</span></code></a> 和 <a class="reference internal" href="#c.PyUnicode_InternInPlace" title="PyUnicode_InternInPlace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_InternInPlace()</span></code></a> 的组合操作，返回一个已内部化的新 Unicode 字符串对象，或一个指向具有相同值的原有内部化字符串对象的新的（“拥有的”）引用。</p>
</dd></dl>

</section>
</section>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">Unicode对象和编解码器</a><ul>
<li><a class="reference internal" href="#unicode-objects">Unicode对象</a><ul>
<li><a class="reference internal" href="#unicode-type">Unicode类型</a></li>
<li><a class="reference internal" href="#unicode-character-properties">Unicode字符属性</a></li>
<li><a class="reference internal" href="#creating-and-accessing-unicode-strings">创建和访问 Unicode 字符串</a></li>
<li><a class="reference internal" href="#deprecated-py-unicode-apis">已弃用的 Py_UNICODE API</a></li>
<li><a class="reference internal" href="#locale-encoding">语言区域编码格式</a></li>
<li><a class="reference internal" href="#file-system-encoding">文件系统编码格式</a></li>
<li><a class="reference internal" href="#wchar-t-support">wchar_t 支持</a></li>
</ul>
</li>
<li><a class="reference internal" href="#built-in-codecs">内置编解码器</a><ul>
<li><a class="reference internal" href="#generic-codecs">泛型编解码器</a></li>
<li><a class="reference internal" href="#utf-8-codecs">UTF-8 编解码器</a></li>
<li><a class="reference internal" href="#utf-32-codecs">UTF-32 编解码器</a></li>
<li><a class="reference internal" href="#utf-16-codecs">UTF-16 编解码器</a></li>
<li><a class="reference internal" href="#utf-7-codecs">UTF-7 编解码器</a></li>
<li><a class="reference internal" href="#unicode-escape-codecs">Unicode-Escape 编解码器</a></li>
<li><a class="reference internal" href="#raw-unicode-escape-codecs">Raw-Unicode-Escape 编解码器</a></li>
<li><a class="reference internal" href="#latin-1-codecs">Latin-1 编解码器</a></li>
<li><a class="reference internal" href="#ascii-codecs">ASCII 编解码器</a></li>
<li><a class="reference internal" href="#character-map-codecs">字符映射编解码器</a></li>
<li><a class="reference internal" href="#mbcs-codecs-for-windows">Windows 中的 MBCS 编解码器</a></li>
<li><a class="reference internal" href="#methods-slots">方法和槽位</a></li>
</ul>
</li>
<li><a class="reference internal" href="#methods-and-slot-functions">方法与槽位函数</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="bytearray.html"
                        title="上一章">字节数组对象</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="tuple.html"
                        title="下一章">元组对象</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/c-api/unicode.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="tuple.html" title="元组对象"
             >下一页</a> |</li>
        <li class="right" >
          <a href="bytearray.html" title="字节数组对象"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.8.19 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API 参考手册</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="concrete.html" >具体的对象层</a> &#187;</li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 4月 29, 2024.
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>

  </body>
</html>