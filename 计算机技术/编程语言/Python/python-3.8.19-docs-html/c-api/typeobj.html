
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>类型对象 &#8212; Python 3.8.19 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.8.19 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="使对象类型支持循环垃圾回收" href="gcsupport.html" />
    <link rel="prev" title="公用对象的结构" href="structures.html" />
    <link rel="canonical" href="https://docs.python.org/3/c-api/typeobj.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">类型对象</a><ul>
<li><a class="reference internal" href="#quick-reference">快速参考</a><ul>
<li><a class="reference internal" href="#tp-slots">&quot;tp_方法槽&quot;</a></li>
<li><a class="reference internal" href="#sub-slots">子方法槽（方法域）</a></li>
<li><a class="reference internal" href="#slot-typedefs">槽位 typedef</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pytypeobject-definition">PyTypeObject 定义</a></li>
<li><a class="reference internal" href="#pyobject-slots">PyObject 槽位</a></li>
<li><a class="reference internal" href="#pyvarobject-slots">PyVarObject 槽位</a></li>
<li><a class="reference internal" href="#pytypeobject-slots">PyTypeObject 槽</a></li>
<li><a class="reference internal" href="#heap-types">堆类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#number-object-structures">数字对象结构体</a></li>
<li><a class="reference internal" href="#mapping-object-structures">映射对象结构体</a></li>
<li><a class="reference internal" href="#sequence-object-structures">序列对象结构体</a></li>
<li><a class="reference internal" href="#buffer-object-structures">缓冲区对象结构体</a></li>
<li><a class="reference internal" href="#async-object-structures">异步对象结构体</a></li>
<li><a class="reference internal" href="#slot-type-typedefs">槽位类型 typedef</a></li>
<li><a class="reference internal" href="#examples">例子</a></li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="structures.html"
                        title="上一章">公用对象的结构</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="gcsupport.html"
                        title="下一章">使对象类型支持循环垃圾回收</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/c-api/typeobj.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="gcsupport.html" title="使对象类型支持循环垃圾回收"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="structures.html" title="公用对象的结构"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.8.19 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API 参考手册</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="objimpl.html" accesskey="U">对象实现支持</a> &#187;</li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="type-objects">
<span id="type-structs"></span><h1>类型对象<a class="headerlink" href="#type-objects" title="永久链接至标题">¶</a></h1>
<p>也许 Python 对象系统中最重要的结构之一就是定义新类型的结构: <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 结构。 类型对象可以使用任何 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_*()</span></code> 或 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_*()</span></code> 函数来处理，但不能提供大多数 Python 应用程序所感兴趣的内容。 这些对象是对象行为的基础，所以它们对解释器本身或任何实现新类型的扩展模块都非常重要。</p>
<p>与大多数标准类型相比，类型对象相当大。这么大的原因是每个类型对象存储了大量的值，大部分是C函数指针，每个指针实现了类型功能的一小部分。本节将详细描述类型对象的字段。这些字段将按照它们在结构中出现的顺序进行描述。</p>
<p>除了下面的快速参考， <a class="reference internal" href="#typedef-examples"><span class="std std-ref">例子</span></a> 小节提供了快速了解 <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 的含义和用法的例子。</p>
<section id="quick-reference">
<h2>快速参考<a class="headerlink" href="#quick-reference" title="永久链接至标题">¶</a></h2>
<section id="tp-slots">
<span id="tp-slots-table"></span><h3>&quot;tp_方法槽&quot;<a class="headerlink" href="#tp-slots" title="永久链接至标题">¶</a></h3>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 31%" />
<col style="width: 31%" />
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 2%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" rowspan="2"><p>PyTypeObject 槽 <a class="footnote-reference brackets" href="#slots" id="id1">1</a></p></th>
<th class="head" rowspan="2"><p><a class="reference internal" href="#slot-typedefs-table"><span class="std std-ref">Type</span></a></p></th>
<th class="head" rowspan="2"><p>特殊方法/属性</p></th>
<th class="head" colspan="4"><p>信息 <a class="footnote-reference brackets" href="#cols" id="id2">2</a></p></th>
</tr>
<tr class="row-even"><th class="head"><p>O</p></th>
<th class="head"><p>T</p></th>
<th class="head"><p>D</p></th>
<th class="head"><p>I</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>&lt;R&gt; <a class="reference internal" href="#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_name</span></code></a></p></td>
<td><p>const char *</p></td>
<td><p>__name__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a></p></td>
<td><p>Py_ssize_t</p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a></p></td>
<td><p>Py_ssize_t</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dealloc</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.destructor" title="destructor"><code class="xref c c-type docutils literal notranslate"><span class="pre">destructor</span></code></a></p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code></a></p></td>
<td><p>Py_ssize_t</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>?</p></td>
</tr>
<tr class="row-even"><td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a>)</p></td>
<td><p><a class="reference internal" href="#c.getattrfunc" title="getattrfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getattrfunc</span></code></a></p></td>
<td><p>__getattribute__,
__getattr__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-odd"><td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a>)</p></td>
<td><p><a class="reference internal" href="#c.setattrfunc" title="setattrfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">setattrfunc</span></code></a></p></td>
<td><p>__setattr__,
__delattr__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_async" title="PyTypeObject.tp_as_async"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_async</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PyAsyncMethods" title="PyAsyncMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyAsyncMethods</span></code></a> *</p></td>
<td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">子方法槽（方法域）</span></a></p></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_repr</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.reprfunc" title="reprfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">reprfunc</span></code></a></p></td>
<td><p>__repr__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_number" title="PyTypeObject.tp_as_number"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_number</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyNumberMethods</span></code></a> *</p></td>
<td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">子方法槽（方法域）</span></a></p></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_sequence" title="PyTypeObject.tp_as_sequence"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_sequence</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PySequenceMethods</span></code></a> *</p></td>
<td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">子方法槽（方法域）</span></a></p></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_mapping" title="PyTypeObject.tp_as_mapping"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_mapping</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PyMappingMethods" title="PyMappingMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMappingMethods</span></code></a> *</p></td>
<td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">子方法槽（方法域）</span></a></p></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.hashfunc" title="hashfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">hashfunc</span></code></a></p></td>
<td><p>__hash__</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ternaryfunc</span></code></a></p></td>
<td><p>__call__</p></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_str" title="PyTypeObject.tp_str"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_str</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.reprfunc" title="reprfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">reprfunc</span></code></a></p></td>
<td><p>__str__</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.getattrofunc" title="getattrofunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getattrofunc</span></code></a></p></td>
<td><p>__getattribute__,
__getattr__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.setattrofunc" title="setattrofunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">setattrofunc</span></code></a></p></td>
<td><p>__setattr__,
__delattr__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_buffer</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PyBufferProcs" title="PyBufferProcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBufferProcs</span></code></a> *</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a></p></td>
<td><p>unsigned long</p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>?</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_doc" title="PyTypeObject.tp_doc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_doc</span></code></a></p></td>
<td><p>const char *</p></td>
<td><p>__doc__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a></p></td>
<td><p><a class="reference internal" href="gcsupport.html#c.traverseproc" title="traverseproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">traverseproc</span></code></a></p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a></p></td>
<td><p><a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry"><code class="xref c c-type docutils literal notranslate"><span class="pre">inquiry</span></code></a></p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.richcmpfunc" title="richcmpfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">richcmpfunc</span></code></a></p></td>
<td><p>__lt__,
__le__,
__eq__,
__ne__,
__gt__,
__ge__</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a></p></td>
<td><p>Py_ssize_t</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.getiterfunc" title="getiterfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getiterfunc</span></code></a></p></td>
<td><p>__iter__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iternext</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.iternextfunc" title="iternextfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">iternextfunc</span></code></a></p></td>
<td><p>__next__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_methods" title="PyTypeObject.tp_methods"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_methods</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> []</p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_members</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyMemberDef" title="PyMemberDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemberDef</span></code></a> []</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_getset" title="PyTypeObject.tp_getset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getset</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyGetSetDef" title="PyGetSetDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyGetSetDef</span></code></a> []</p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_base</span></code></a></p></td>
<td><p><a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> *</p></td>
<td><p>__base__</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>__dict__</p></td>
<td></td>
<td></td>
<td><p>?</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_descr_get" title="PyTypeObject.tp_descr_get"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descr_get</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.descrgetfunc" title="descrgetfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">descrgetfunc</span></code></a></p></td>
<td><p>__get__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_descr_set" title="PyTypeObject.tp_descr_set"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descr_set</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.descrsetfunc" title="descrsetfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">descrsetfunc</span></code></a></p></td>
<td><p>__set__,
__delete__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a></p></td>
<td><p>Py_ssize_t</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.initproc" title="initproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">initproc</span></code></a></p></td>
<td><p>__init__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_alloc</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.allocfunc" title="allocfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">allocfunc</span></code></a></p></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.newfunc" title="newfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">newfunc</span></code></a></p></td>
<td><p>__new__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.freefunc" title="freefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">freefunc</span></code></a></p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_is_gc" title="PyTypeObject.tp_is_gc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_is_gc</span></code></a></p></td>
<td><p><a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry"><code class="xref c c-type docutils literal notranslate"><span class="pre">inquiry</span></code></a></p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p>&lt;<a class="reference internal" href="#c.PyTypeObject.tp_bases" title="PyTypeObject.tp_bases"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_bases</span></code></a>&gt;</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>__bases__</p></td>
<td></td>
<td></td>
<td><p>~</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>&lt;<a class="reference internal" href="#c.PyTypeObject.tp_mro" title="PyTypeObject.tp_mro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_mro</span></code></a>&gt;</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>__mro__</p></td>
<td></td>
<td></td>
<td><p>~</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_cache" title="PyTypeObject.tp_cache"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_cache</span></code></a>]</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-odd"><td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_subclasses" title="PyTypeObject.tp_subclasses"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_subclasses</span></code></a>]</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>__subclasses__</p></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-even"><td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklist</span></code></a>]</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-odd"><td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_del" title="PyTypeObject.tp_del"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_del</span></code></a>)</p></td>
<td><p><a class="reference internal" href="#c.destructor" title="destructor"><code class="xref c c-type docutils literal notranslate"><span class="pre">destructor</span></code></a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_version_tag" title="PyTypeObject.tp_version_tag"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_version_tag</span></code></a>]</p></td>
<td><p>unsigned int</p></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.destructor" title="destructor"><code class="xref c c-type docutils literal notranslate"><span class="pre">destructor</span></code></a></p></td>
<td><p>__del__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
</tbody>
</table>
<p>如果定义了 <code class="xref py py-const docutils literal notranslate"><span class="pre">COUNT_ALLOCS</span></code> ，则还存在以下（仅内部）字段：</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.PyTypeObject.tp_allocs" title="PyTypeObject.tp_allocs"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_allocs</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyTypeObject.tp_frees" title="PyTypeObject.tp_frees"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_frees</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyTypeObject.tp_maxalloc" title="PyTypeObject.tp_maxalloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_maxalloc</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyTypeObject.tp_prev" title="PyTypeObject.tp_prev"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_prev</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyTypeObject.tp_next" title="PyTypeObject.tp_next"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_next</span></code></a></p></li>
</ul>
<dl class="footnote brackets">
<dt class="label" id="slots"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>小括号中的槽名表示它(实际上)已弃用。尖括号中的名称应该被视为只读的。方括号中的名称仅供内部使用。&quot;&lt;R&gt;&quot;(作为前缀)表示该字段是必需的(必须是非null)。</p>
</dd>
<dt class="label" id="cols"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>列：</p>
<p><strong>&quot;O&quot;</strong>:  <code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> 必须设置</p>
<p><strong>&quot;T&quot;</strong>: <a class="reference internal" href="type.html#c.PyType_Type" title="PyType_Type"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyType_Type</span></code></a> 必须设置</p>
<p><strong>&quot;D&quot;</strong>: 默认设置(如果方法槽被设置为NULL)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X - PyType_Ready sets this value if it is NULL
~ - PyType_Ready always sets this value (it should be NULL)
? - PyType_Ready may set this value depending on other slots

Also see the inheritance column (&quot;I&quot;).
</pre></div>
</div>
<p><strong>&quot;I&quot;</strong>: 继承</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X - type slot is inherited via PyType_Ready if defined with a NULL value
% - the slots of the sub-struct are inherited individually
G - inherited, but only in combination with other slots; see the slot&#39;s description
? - it&#39;s complicated; see the slot&#39;s description
</pre></div>
</div>
<p>注意，有些方法槽是通过普通属性查找链有效继承的。</p>
</dd>
</dl>
</section>
<section id="sub-slots">
<span id="id3"></span><h3>子方法槽（方法域）<a class="headerlink" href="#sub-slots" title="永久链接至标题">¶</a></h3>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 47%" />
<col style="width: 31%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>方法槽</p></th>
<th class="head"><p><a class="reference internal" href="#slot-typedefs-table"><span class="std std-ref">Type</span></a></p></th>
<th class="head"><p>特殊方法</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyAsyncMethods.am_await" title="PyAsyncMethods.am_await"><code class="xref c c-member docutils literal notranslate"><span class="pre">am_await</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__await__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyAsyncMethods.am_aiter" title="PyAsyncMethods.am_aiter"><code class="xref c c-member docutils literal notranslate"><span class="pre">am_aiter</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__aiter__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyAsyncMethods.am_anext" title="PyAsyncMethods.am_anext"><code class="xref c c-member docutils literal notranslate"><span class="pre">am_anext</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__anext__</p></td>
</tr>
<tr class="row-odd"><td colspan="3"></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_add" title="PyNumberMethods.nb_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_add</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__add__
__radd__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_add" title="PyNumberMethods.nb_inplace_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_add</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__iadd__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_subtract" title="PyNumberMethods.nb_subtract"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_subtract</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__sub__
__rsub__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_subtract" title="PyNumberMethods.nb_inplace_subtract"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_subtract</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__sub__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_multiply" title="PyNumberMethods.nb_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_multiply</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__mul__
__rmul__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_multiply" title="PyNumberMethods.nb_inplace_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_multiply</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__mul__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_remainder" title="PyNumberMethods.nb_remainder"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_remainder</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__mod__
__rmod__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_remainder" title="PyNumberMethods.nb_inplace_remainder"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_remainder</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__mod__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_divmod" title="PyNumberMethods.nb_divmod"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_divmod</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__divmod__
__rdivmod__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_power" title="PyNumberMethods.nb_power"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_power</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ternaryfunc</span></code></a></p></td>
<td><p>__pow__
__rpow__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_power" title="PyNumberMethods.nb_inplace_power"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_power</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ternaryfunc</span></code></a></p></td>
<td><p>__pow__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_negative" title="PyNumberMethods.nb_negative"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_negative</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__neg__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_positive" title="PyNumberMethods.nb_positive"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_positive</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__pos__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_absolute" title="PyNumberMethods.nb_absolute"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_absolute</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__abs__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_bool" title="PyNumberMethods.nb_bool"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_bool</span></code></a></p></td>
<td><p><a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry"><code class="xref c c-type docutils literal notranslate"><span class="pre">inquiry</span></code></a></p></td>
<td><p>__bool__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_invert" title="PyNumberMethods.nb_invert"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_invert</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__invert__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_lshift" title="PyNumberMethods.nb_lshift"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_lshift</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__lshift__
__rlshift__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_lshift" title="PyNumberMethods.nb_inplace_lshift"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_lshift</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__lshift__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_rshift" title="PyNumberMethods.nb_rshift"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_rshift</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__rshift__
__rrshift__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_rshift" title="PyNumberMethods.nb_inplace_rshift"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_rshift</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__rshift__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_and" title="PyNumberMethods.nb_and"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_and</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__and__
__rand__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_and" title="PyNumberMethods.nb_inplace_and"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_and</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__and__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_xor" title="PyNumberMethods.nb_xor"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_xor</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__xor__
__rxor__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_xor" title="PyNumberMethods.nb_inplace_xor"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_xor</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__xor__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_or" title="PyNumberMethods.nb_or"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_or</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__or__
__ror__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_or" title="PyNumberMethods.nb_inplace_or"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_or</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__or__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_int" title="PyNumberMethods.nb_int"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_int</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__int__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_reserved" title="PyNumberMethods.nb_reserved"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_reserved</span></code></a></p></td>
<td><p>void *</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_float" title="PyNumberMethods.nb_float"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_float</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__float__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_floor_divide" title="PyNumberMethods.nb_floor_divide"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_floor_divide</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__floordiv__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_floor_divide" title="PyNumberMethods.nb_inplace_floor_divide"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_floor_divide</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__floordiv__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_true_divide" title="PyNumberMethods.nb_true_divide"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_true_divide</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__truediv__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_true_divide" title="PyNumberMethods.nb_inplace_true_divide"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_true_divide</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__truediv__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_index" title="PyNumberMethods.nb_index"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_index</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__index__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_matrix_multiply" title="PyNumberMethods.nb_matrix_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_matrix_multiply</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__matmul__
__rmatmul__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_matrix_multiply" title="PyNumberMethods.nb_inplace_matrix_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_matrix_multiply</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__matmul__</p></td>
</tr>
<tr class="row-even"><td colspan="3"></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyMappingMethods.mp_length" title="PyMappingMethods.mp_length"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_length</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.lenfunc" title="lenfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">lenfunc</span></code></a></p></td>
<td><p>__len__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyMappingMethods.mp_subscript" title="PyMappingMethods.mp_subscript"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_subscript</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__getitem__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyMappingMethods.mp_ass_subscript" title="PyMappingMethods.mp_ass_subscript"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_ass_subscript</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.objobjargproc" title="objobjargproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">objobjargproc</span></code></a></p></td>
<td><p>__setitem__,
__delitem__</p></td>
</tr>
<tr class="row-even"><td colspan="3"></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_length" title="PySequenceMethods.sq_length"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_length</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.lenfunc" title="lenfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">lenfunc</span></code></a></p></td>
<td><p>__len__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_concat" title="PySequenceMethods.sq_concat"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_concat</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__add__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_repeat" title="PySequenceMethods.sq_repeat"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_repeat</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeargfunc</span></code></a></p></td>
<td><p>__mul__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_item" title="PySequenceMethods.sq_item"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_item</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeargfunc</span></code></a></p></td>
<td><p>__getitem__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_ass_item" title="PySequenceMethods.sq_ass_item"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_ass_item</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ssizeobjargproc" title="ssizeobjargproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeobjargproc</span></code></a></p></td>
<td><p>__setitem__
__delitem__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_contains" title="PySequenceMethods.sq_contains"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_contains</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.objobjproc" title="objobjproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">objobjproc</span></code></a></p></td>
<td><p>__contains__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_inplace_concat" title="PySequenceMethods.sq_inplace_concat"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_inplace_concat</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__iadd__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_inplace_repeat" title="PySequenceMethods.sq_inplace_repeat"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_inplace_repeat</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeargfunc</span></code></a></p></td>
<td><p>__imul__</p></td>
</tr>
<tr class="row-odd"><td colspan="3"></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyBufferProcs.bf_getbuffer" title="PyBufferProcs.bf_getbuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">bf_getbuffer</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.getbufferproc" title="getbufferproc"><code class="xref c c-func docutils literal notranslate"><span class="pre">getbufferproc()</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">bf_releasebuffer</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.releasebufferproc" title="releasebufferproc"><code class="xref c c-func docutils literal notranslate"><span class="pre">releasebufferproc()</span></code></a></p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="slot-typedefs">
<span id="slot-typedefs-table"></span><h3>槽位 typedef<a class="headerlink" href="#slot-typedefs" title="永久链接至标题">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 36%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>typedef</p></th>
<th class="head"><p>参数类型</p></th>
<th class="head"><p>返回类型</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#c.allocfunc" title="allocfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">allocfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> *</div>
<div class="line">Py_ssize_t</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.destructor" title="destructor"><code class="xref c c-type docutils literal notranslate"><span class="pre">destructor</span></code></a></p></td>
<td><p>void *</p></td>
<td><p>void</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.freefunc" title="freefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">freefunc</span></code></a></p></td>
<td><p>void *</p></td>
<td><p>void</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gcsupport.html#c.traverseproc" title="traverseproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">traverseproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line">void *</div>
<div class="line"><a class="reference internal" href="gcsupport.html#c.visitproc" title="visitproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">visitproc</span></code></a></div>
<div class="line">void *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.newfunc" title="newfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">newfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.initproc" title="initproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">initproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.reprfunc" title="reprfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">reprfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.getattrfunc" title="getattrfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getattrfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line">const char *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.setattrfunc" title="setattrfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">setattrfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line">const char *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.getattrofunc" title="getattrofunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getattrofunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.setattrofunc" title="setattrofunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">setattrofunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.descrgetfunc" title="descrgetfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">descrgetfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.descrsetfunc" title="descrsetfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">descrsetfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.hashfunc" title="hashfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">hashfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>Py_hash_t</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.richcmpfunc" title="richcmpfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">richcmpfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line">int</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.getiterfunc" title="getiterfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getiterfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.iternextfunc" title="iternextfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">iternextfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.lenfunc" title="lenfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">lenfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>Py_ssize_t</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.getbufferproc" title="getbufferproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getbufferproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> *</div>
<div class="line">int</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.releasebufferproc" title="releasebufferproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">releasebufferproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> *</div>
</div>
</td>
<td><p>void</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry"><code class="xref c c-type docutils literal notranslate"><span class="pre">inquiry</span></code></a></p></td>
<td><p>void *</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ternaryfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeargfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line">Py_ssize_t</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.ssizeobjargproc" title="ssizeobjargproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeobjargproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line">Py_ssize_t</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.objobjproc" title="objobjproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">objobjproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.objobjargproc" title="objobjargproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">objobjargproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
</tbody>
</table>
<p>请参阅 <a class="reference internal" href="#id5"><span class="std std-ref">槽位类型 typedef</span></a> 里有更多详细信息。</p>
</section>
</section>
<section id="pytypeobject-definition">
<h2>PyTypeObject 定义<a class="headerlink" href="#pytypeobject-definition" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 的结构定义可以在 <code class="file docutils literal notranslate"><span class="pre">Include/object.h</span></code> 中找到。 为了方便参考，此处复述了其中的定义:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_typeobject</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyObject_VAR_HEAD</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">tp_name</span><span class="p">;</span><span class="w"> </span><span class="cm">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span>
<span class="w">    </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">tp_basicsize</span><span class="p">,</span><span class="w"> </span><span class="n">tp_itemsize</span><span class="p">;</span><span class="w"> </span><span class="cm">/* For allocation */</span>

<span class="w">    </span><span class="cm">/* Methods to implement standard operations */</span>

<span class="w">    </span><span class="n">destructor</span><span class="w"> </span><span class="n">tp_dealloc</span><span class="p">;</span>
<span class="w">    </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">tp_vectorcall_offset</span><span class="p">;</span>
<span class="w">    </span><span class="n">getattrfunc</span><span class="w"> </span><span class="n">tp_getattr</span><span class="p">;</span>
<span class="w">    </span><span class="n">setattrfunc</span><span class="w"> </span><span class="n">tp_setattr</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyAsyncMethods</span><span class="w"> </span><span class="o">*</span><span class="n">tp_as_async</span><span class="p">;</span><span class="w"> </span><span class="cm">/* formerly known as tp_compare (Python 2)</span>
<span class="cm">                                    or tp_reserved (Python 3) */</span>
<span class="w">    </span><span class="n">reprfunc</span><span class="w"> </span><span class="n">tp_repr</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Method suites for standard classes */</span>

<span class="w">    </span><span class="n">PyNumberMethods</span><span class="w"> </span><span class="o">*</span><span class="n">tp_as_number</span><span class="p">;</span>
<span class="w">    </span><span class="n">PySequenceMethods</span><span class="w"> </span><span class="o">*</span><span class="n">tp_as_sequence</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyMappingMethods</span><span class="w"> </span><span class="o">*</span><span class="n">tp_as_mapping</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* More standard operations (here for binary compatibility) */</span>

<span class="w">    </span><span class="n">hashfunc</span><span class="w"> </span><span class="n">tp_hash</span><span class="p">;</span>
<span class="w">    </span><span class="n">ternaryfunc</span><span class="w"> </span><span class="n">tp_call</span><span class="p">;</span>
<span class="w">    </span><span class="n">reprfunc</span><span class="w"> </span><span class="n">tp_str</span><span class="p">;</span>
<span class="w">    </span><span class="n">getattrofunc</span><span class="w"> </span><span class="n">tp_getattro</span><span class="p">;</span>
<span class="w">    </span><span class="n">setattrofunc</span><span class="w"> </span><span class="n">tp_setattro</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Functions to access object as input/output buffer */</span>
<span class="w">    </span><span class="n">PyBufferProcs</span><span class="w"> </span><span class="o">*</span><span class="n">tp_as_buffer</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Flags to define presence of optional/expanded features */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">tp_flags</span><span class="p">;</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">tp_doc</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Documentation string */</span>

<span class="w">    </span><span class="cm">/* call function for all accessible objects */</span>
<span class="w">    </span><span class="n">traverseproc</span><span class="w"> </span><span class="n">tp_traverse</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* delete references to contained objects */</span>
<span class="w">    </span><span class="n">inquiry</span><span class="w"> </span><span class="n">tp_clear</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* rich comparisons */</span>
<span class="w">    </span><span class="n">richcmpfunc</span><span class="w"> </span><span class="n">tp_richcompare</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* weak reference enabler */</span>
<span class="w">    </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">tp_weaklistoffset</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Iterators */</span>
<span class="w">    </span><span class="n">getiterfunc</span><span class="w"> </span><span class="n">tp_iter</span><span class="p">;</span>
<span class="w">    </span><span class="n">iternextfunc</span><span class="w"> </span><span class="n">tp_iternext</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Attribute descriptor and subclassing stuff */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">PyMethodDef</span><span class="w"> </span><span class="o">*</span><span class="n">tp_methods</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">PyMemberDef</span><span class="w"> </span><span class="o">*</span><span class="n">tp_members</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">PyGetSetDef</span><span class="w"> </span><span class="o">*</span><span class="n">tp_getset</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">_typeobject</span><span class="w"> </span><span class="o">*</span><span class="n">tp_base</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">tp_dict</span><span class="p">;</span>
<span class="w">    </span><span class="n">descrgetfunc</span><span class="w"> </span><span class="n">tp_descr_get</span><span class="p">;</span>
<span class="w">    </span><span class="n">descrsetfunc</span><span class="w"> </span><span class="n">tp_descr_set</span><span class="p">;</span>
<span class="w">    </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">tp_dictoffset</span><span class="p">;</span>
<span class="w">    </span><span class="n">initproc</span><span class="w"> </span><span class="n">tp_init</span><span class="p">;</span>
<span class="w">    </span><span class="n">allocfunc</span><span class="w"> </span><span class="n">tp_alloc</span><span class="p">;</span>
<span class="w">    </span><span class="n">newfunc</span><span class="w"> </span><span class="n">tp_new</span><span class="p">;</span>
<span class="w">    </span><span class="n">freefunc</span><span class="w"> </span><span class="n">tp_free</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Low-level free-memory routine */</span>
<span class="w">    </span><span class="n">inquiry</span><span class="w"> </span><span class="n">tp_is_gc</span><span class="p">;</span><span class="w"> </span><span class="cm">/* For PyObject_IS_GC */</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">tp_bases</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">tp_mro</span><span class="p">;</span><span class="w"> </span><span class="cm">/* method resolution order */</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">tp_cache</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">tp_subclasses</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">tp_weaklist</span><span class="p">;</span>
<span class="w">    </span><span class="n">destructor</span><span class="w"> </span><span class="n">tp_del</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Type attribute cache version tag. Added in version 2.6 */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tp_version_tag</span><span class="p">;</span>

<span class="w">    </span><span class="n">destructor</span><span class="w"> </span><span class="n">tp_finalize</span><span class="p">;</span>

<span class="p">}</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="pyobject-slots">
<h2>PyObject 槽位<a class="headerlink" href="#pyobject-slots" title="永久链接至标题">¶</a></h2>
<p>type 对象结构扩展了 <a class="reference internal" href="structures.html#c.PyVarObject" title="PyVarObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyVarObject</span></code></a> 结构。 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> 字段用于动态类型 (由 <code class="xref py py-func docutils literal notranslate"><span class="pre">type_new()</span></code> 创建，通常通过 class 语句来调用)。 注意 <a class="reference internal" href="type.html#c.PyType_Type" title="PyType_Type"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyType_Type</span></code></a> (元类型) 会初始化 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>，这意味着它的实例 (即 type 对象) <em>必须</em> 具有 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> 字段。</p>
<dl class="member">
<dt id="c.PyObject._ob_next">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject._ob_next</code><a class="headerlink" href="#c.PyObject._ob_next" title="永久链接至目标">¶</a></dt>
<dt id="c.PyObject._ob_prev">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject._ob_prev</code><a class="headerlink" href="#c.PyObject._ob_prev" title="永久链接至目标">¶</a></dt>
<dd><p>These fields are only present when the macro <code class="docutils literal notranslate"><span class="pre">Py_TRACE_REFS</span></code> is defined.
Their initialization to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is taken care of by the <code class="docutils literal notranslate"><span class="pre">PyObject_HEAD_INIT</span></code>
macro.  For statically allocated objects, these fields always remain <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
For dynamically allocated objects, these two fields are used to link the object
into a doubly-linked list of <em>all</em> live objects on the heap.  This could be used
for various debugging purposes; currently the only use is to print the objects
that are still alive at the end of a run when the environment variable
<span class="target" id="index-0"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDUMPREFS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDUMPREFS</span></code></a> is set.</p>
<p><strong>继承：</strong></p>
<p>这些字段不会被子类型继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyObject.ob_refcnt">
Py_ssize_t <code class="sig-name descname">PyObject.ob_refcnt</code><a class="headerlink" href="#c.PyObject.ob_refcnt" title="永久链接至目标">¶</a></dt>
<dd><p>这是类型对象的引用计数，由 <code class="docutils literal notranslate"><span class="pre">PyObject_HEAD_INIT</span></code> 宏初始化为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。 请注意对于静态分配的类型对象 (对象的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_type</span></code> 指回该类型) <em>不会</em> 被加入引用计数。 但对于动态分配的类型对象，实例 <em>确实</em> 会被算作引用。</p>
<p><strong>继承：</strong></p>
<p>子类型不继承此字段。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyObject.ob_type">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a>* <code class="sig-name descname">PyObject.ob_type</code><a class="headerlink" href="#c.PyObject.ob_type" title="永久链接至目标">¶</a></dt>
<dd><p>这是类型的类型，换句话说就是元类型，它由宏 <code class="docutils literal notranslate"><span class="pre">PyObject_HEAD_INIT</span></code> 的参数来做初始化，它的值一般情况下是 <code class="docutils literal notranslate"><span class="pre">&amp;PyType_Type</span></code> 。可是为了使动态可载入扩展模块至少在Windows上可用，编译器会报错这是一个不可用的初始化。因此按照惯例传递 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 给宏 <code class="docutils literal notranslate"><span class="pre">PyObject_HEAD_INIT</span></code> 并且在模块的初始化函数开始时候其他任何操作之前初始化这个字段。典型做法是这样的：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Foo_Type</span><span class="p">.</span><span class="n">ob_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">;</span>
</pre></div>
</div>
<p>这应该在创建该类型的任何实例之前完成。<a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 检查 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_type</span></code> 是否为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，如果是，则用基类的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_type</span></code> 字段初始化它。如果该字段非零，则 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 不会更改它。</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
</dd></dl>

</section>
<section id="pyvarobject-slots">
<h2>PyVarObject 槽位<a class="headerlink" href="#pyvarobject-slots" title="永久链接至标题">¶</a></h2>
<dl class="member">
<dt id="c.PyVarObject.ob_size">
Py_ssize_t <code class="sig-name descname">PyVarObject.ob_size</code><a class="headerlink" href="#c.PyVarObject.ob_size" title="永久链接至目标">¶</a></dt>
<dd><p>For statically allocated type objects, this should be initialized to zero.  For
dynamically allocated type objects, this field has a special internal meaning.</p>
<p><strong>继承：</strong></p>
<p>子类型不继承此字段。</p>
</dd></dl>

</section>
<section id="pytypeobject-slots">
<h2>PyTypeObject 槽<a class="headerlink" href="#pytypeobject-slots" title="永久链接至标题">¶</a></h2>
<p>每个槽位都有一个部分来描述继承关系。如果 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 会在该字段为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时设置它的值，那么也会有一个“默认”部分。（注意，在 <code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> 和 <a class="reference internal" href="type.html#c.PyType_Type" title="PyType_Type"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyType_Type</span></code></a> 中设置的许多字段实际上就是默认值。）</p>
<dl class="member">
<dt id="c.PyTypeObject.tp_name">
const char* <code class="sig-name descname">PyTypeObject.tp_name</code><a class="headerlink" href="#c.PyTypeObject.tp_name" title="永久链接至目标">¶</a></dt>
<dd><p>指针，指向以 NULL 结尾的表示类型名称的字符串。对于可以作为模块的全局变量访问的类型，字符串应该是完整的模块名，后跟一个点，再后跟类型名。对于内置类型，字符串应该只是类型名。如果模块是包的子模块，则完整的包名是完整的模块名的一部分。例如，包 <code class="xref py py-mod docutils literal notranslate"><span class="pre">P</span></code> 的子包 <code class="xref py py-mod docutils literal notranslate"><span class="pre">Q</span></code> 的模块 <code class="xref py py-mod docutils literal notranslate"><span class="pre">M</span></code> 中定义的类型 <code class="xref py py-class docutils literal notranslate"><span class="pre">T</span></code> 的 <a class="reference internal" href="#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_name</span></code></a> 应该初始化为 <code class="docutils literal notranslate"><span class="pre">&quot;P.Q.M.T&quot;</span></code>。</p>
<p>For dynamically allocated type objects, this should just be the type name, and
the module name explicitly stored in the type dict as the value for key
<code class="docutils literal notranslate"><span class="pre">'__module__'</span></code>.</p>
<p>For statically allocated type objects, the tp_name field should contain a dot.
Everything before the last dot is made accessible as the <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code>
attribute, and everything after the last dot is made accessible as the
<a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> attribute.</p>
<p>如果不存在点号，则整个 <a class="reference internal" href="#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_name</span></code></a> 字段将作为 <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 属性访问，而 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 属性则将是未定义的（除非在字典中显式地设置，如上文所述）。 这意味着你的类型将无法执行 pickle。 此外，用 pydoc 创建的模块文档中也不会列出该类型。</p>
<p>该字段不可为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 它是 <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyTypeObject()</span></code></a> 中唯一的必填字段（除了潜在的 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 以外）。</p>
<p><strong>继承：</strong></p>
<p>子类型不继承此字段。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_basicsize">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_basicsize</code><a class="headerlink" href="#c.PyTypeObject.tp_basicsize" title="永久链接至目标">¶</a></dt>
<dt id="c.PyTypeObject.tp_itemsize">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_itemsize</code><a class="headerlink" href="#c.PyTypeObject.tp_itemsize" title="永久链接至目标">¶</a></dt>
<dd><p>通过这些字段可以计算出该类型实例以字节为单位的大小。</p>
<p>存在两种类型：具有固定长度实例的类型其 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 字段为零；具有可变长度实例的类型其 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 字段不为零。 对于具有固定长度实例的类型，所有实例的大小都相同，具体大小由 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> 给出。</p>
<p>For a type with variable-length instances, the instances must have an
<code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> field, and the instance size is <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> plus N
times <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>, where N is the &quot;length&quot; of the object.  The value of
N is typically stored in the instance's <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> field.  There are
exceptions:  for example, ints use a negative <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> to indicate a
negative number, and N is <code class="docutils literal notranslate"><span class="pre">abs(ob_size)</span></code> there.  Also, the presence of an
<code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> field in the instance layout doesn't mean that the instance
structure is variable-length (for example, the structure for the list type has
fixed-length instances, yet those instances have a meaningful <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code>
field).</p>
<p>The basic size includes the fields in the instance declared by the macro
<a class="reference internal" href="structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_HEAD</span></code></a> or <a class="reference internal" href="structures.html#c.PyObject_VAR_HEAD" title="PyObject_VAR_HEAD"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_VAR_HEAD</span></code></a> (whichever is used to
declare the instance struct) and this in turn includes the <code class="xref py py-attr docutils literal notranslate"><span class="pre">_ob_prev</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">_ob_next</span></code> fields if they are present.  This means that the only correct
way to get an initializer for the <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> is to use the
<code class="docutils literal notranslate"><span class="pre">sizeof</span></code> operator on the struct used to declare the instance layout.
The basic size does not include the GC header size.</p>
<p>关于对齐的说明：如果变量条目需要特定的对齐，则应通过 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> 的值来处理。 例如：假设某个类型实现了一个 <code class="docutils literal notranslate"><span class="pre">double</span></code> 数组。 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 就是 <code class="docutils literal notranslate"><span class="pre">sizeof(double)</span></code>。 程序员有责任确保 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> 是 <code class="docutils literal notranslate"><span class="pre">sizeof(double)</span></code> 的倍数（假设这是 <code class="docutils literal notranslate"><span class="pre">double</span></code> 的对齐要求）。</p>
<p>对于任何具有可变长度实例的类型，该字段不可为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p><strong>继承：</strong></p>
<p>这些字段将由子类分别继承。 如果基本类型有一个非零的 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>，那么在子类型中将 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 设置为不同的非零值通常是不安全的（不过这取决于该基本类型的具体实现）。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_dealloc">
<a class="reference internal" href="#c.destructor" title="destructor">destructor</a> <code class="sig-name descname">PyTypeObject.tp_dealloc</code><a class="headerlink" href="#c.PyTypeObject.tp_dealloc" title="永久链接至目标">¶</a></dt>
<dd><p>指向实例析构函数的指针。除非保证类型的实例永远不会被释放（就像单例对象 <code class="docutils literal notranslate"><span class="pre">None</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> 那样），否则必须定义这个函数。函数声明如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">tp_dealloc</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>当引用计数为0时，由 <a class="reference internal" href="refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a> 和 <a class="reference internal" href="refcounting.html#c.Py_XDECREF" title="Py_XDECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_XDECREF()</span></code></a> 宏调用析构函数。此时，实例仍然存在，但已经没有了对它的引用。析构函数应该释放该实例拥有的所有引用，释放该实例拥有的所有内存缓冲区（通过分配内存对应的释放函数），并调用该类型的 <a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a> 函数。如果该类型不可子类型化（没有设置 <a class="reference internal" href="#Py_TPFLAGS_BASETYPE" title="Py_TPFLAGS_BASETYPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_BASETYPE</span></code></a> 标志位），则允许直接调用对象的释放函数，不必调用 <a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a>。对象的释放函数应该与分配函数对应：如果使用 <a class="reference internal" href="allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_New()</span></code></a> 或 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_VarNew()</span></code> 分配，通常为 <a class="reference internal" href="allocation.html#c.PyObject_Del" title="PyObject_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Del()</span></code></a>；如果使用 <a class="reference internal" href="gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_New()</span></code></a> 或 <a class="reference internal" href="gcsupport.html#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_NewVar()</span></code></a> 分配，通常为 <a class="reference internal" href="gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Del()</span></code></a>。</p>
<p>最后，如果该类型是在堆上分配的（<a class="reference internal" href="#Py_TPFLAGS_HEAPTYPE" title="Py_TPFLAGS_HEAPTYPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HEAPTYPE</span></code></a>），释放器应该在调用类型释放器后减少类型对象的引用计数。为了避免空悬指针，建议的实现方法为：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo_dealloc</span><span class="p">(</span><span class="n">foo_object</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="o">*</span><span class="n">tp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// free references and buffers here</span>
<span class="w">    </span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_vectorcall_offset">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_vectorcall_offset</code><a class="headerlink" href="#c.PyTypeObject.tp_vectorcall_offset" title="永久链接至目标">¶</a></dt>
<dd><p>An optional offset to a per-instance function that implements calling
the object using the <em>vectorcall</em> protocol, a more efficient alternative
of the simpler <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>.</p>
<p>This field is only used if the flag <a class="reference internal" href="#_Py_TPFLAGS_HAVE_VECTORCALL" title="_Py_TPFLAGS_HAVE_VECTORCALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code></a>
is set. If so, this must be a positive integer containing the offset in the
instance of a <a class="reference internal" href="#c.vectorcallfunc" title="vectorcallfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">vectorcallfunc</span></code></a> pointer.
The signature is the same as for <a class="reference internal" href="object.html#c._PyObject_Vectorcall" title="_PyObject_Vectorcall"><code class="xref c c-func docutils literal notranslate"><span class="pre">_PyObject_Vectorcall()</span></code></a>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">vectorcallfunc</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">callable</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nargsf</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">kwnames</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>vectorcallfunc</em> pointer may be zero, in which case the instance behaves
as if <a class="reference internal" href="#_Py_TPFLAGS_HAVE_VECTORCALL" title="_Py_TPFLAGS_HAVE_VECTORCALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code></a> was not set: calling the instance
falls back to <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>.</p>
<p>Any class that sets <code class="docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code> must also set
<a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a> and make sure its behaviour is consistent
with the <em>vectorcallfunc</em> function.
This can be done by setting <em>tp_call</em> to <code class="docutils literal notranslate"><span class="pre">PyVectorcall_Call</span></code>:</p>
<dl class="function">
<dt id="c.PyVectorcall_Call">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">PyVectorcall_Call</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *tuple</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *dict</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyVectorcall_Call" title="永久链接至目标">¶</a></dt>
<dd><p>Call <em>callable</em>'s <em>vectorcallfunc</em> with positional and keyword
arguments given in a tuple and dict, respectively.</p>
<p>This function is intended to be used in the <code class="docutils literal notranslate"><span class="pre">tp_call</span></code> slot.
It does not fall back to <code class="docutils literal notranslate"><span class="pre">tp_call</span></code> and it currently does not check the
<code class="docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code> flag.
To call an object, use one of the <a class="reference internal" href="object.html#c.PyObject_Call" title="PyObject_Call"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Call</span></code></a>
functions instead.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">注解</p>
<p>It is not recommended for <a class="reference internal" href="#heap-types"><span class="std std-ref">heap types</span></a> to implement
the vectorcall protocol.
When a user sets <code class="docutils literal notranslate"><span class="pre">__call__</span></code> in Python code, only <code class="docutils literal notranslate"><span class="pre">tp_call</span></code> is updated,
possibly making it inconsistent with the vectorcall function.</p>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>The semantics of the <code class="docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code> slot are provisional and
expected to be finalized in Python 3.9.
If you use vectorcall, plan for updating your code for Python 3.9.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>This slot was used for print formatting in Python 2.x.
In Python 3.0 to 3.7, it was reserved and named <code class="docutils literal notranslate"><span class="pre">tp_print</span></code>.</p>
</div>
<p><strong>继承：</strong></p>
<p>This field is inherited by subtypes together with
<a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>: a subtype inherits
<a class="reference internal" href="#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code></a> from its base type when
the subtype’s <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>Note that <a class="reference internal" href="#id4">heap types</a> (including subclasses defined in Python) do not
inherit the <a class="reference internal" href="#_Py_TPFLAGS_HAVE_VECTORCALL" title="_Py_TPFLAGS_HAVE_VECTORCALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code></a> flag.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_getattr">
<a class="reference internal" href="#c.getattrfunc" title="getattrfunc">getattrfunc</a> <code class="sig-name descname">PyTypeObject.tp_getattr</code><a class="headerlink" href="#c.PyTypeObject.tp_getattr" title="永久链接至目标">¶</a></dt>
<dd><p>一个指向获取属性字符串函数的可选指针。</p>
<p>该字段已弃用。当它被定义时，应该和 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a> 指向同一个函数，但接受一个C字符串参数表示属性名，而不是Python字符串对象。</p>
<p><strong>继承：</strong></p>
<p>分组: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_getattr</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_getattro</span></code></p>
<p>该字段会被子类和 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a> 所继承：当子类型的 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a> 均为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时该子类型将从它的基类型同时继承 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a>。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_setattr">
<a class="reference internal" href="#c.setattrfunc" title="setattrfunc">setattrfunc</a> <code class="sig-name descname">PyTypeObject.tp_setattr</code><a class="headerlink" href="#c.PyTypeObject.tp_setattr" title="永久链接至目标">¶</a></dt>
<dd><p>一个指向函数以便设置和删除属性的可选指针。</p>
<p>该字段已弃用。当它被定义时，应该和 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a> 指向同一个函数，但接受一个C字符串参数表示属性名，而不是Python字符串对象。</p>
<p><strong>继承：</strong></p>
<p>分组: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_setattr</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_setattro</span></code></p>
<p>该字段会被子类型和 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a> 所继承：当子类型的 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a> 均为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时该子类型将同时从它的基类型继承 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a>。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_as_async">
<a class="reference internal" href="#c.PyAsyncMethods" title="PyAsyncMethods">PyAsyncMethods</a>* <code class="sig-name descname">PyTypeObject.tp_as_async</code><a class="headerlink" href="#c.PyTypeObject.tp_as_async" title="永久链接至目标">¶</a></dt>
<dd><p>指向一个包含仅与在 C 层级上实现 <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> 和 <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> 协议的对象相关联的字段的附加结构体。 请参阅 <a class="reference internal" href="#async-structs"><span class="std std-ref">异步对象结构体</span></a> 了解详情。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能: </span>在之前被称为 <code class="docutils literal notranslate"><span class="pre">tp_compare</span></code> 和 <code class="docutils literal notranslate"><span class="pre">tp_reserved</span></code>。</p>
</div>
<p><strong>继承：</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_async" title="PyTypeObject.tp_as_async"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_async</span></code></a> 字段不会被继承，但所包含的字段会被单独继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_repr">
<a class="reference internal" href="#c.reprfunc" title="reprfunc">reprfunc</a> <code class="sig-name descname">PyTypeObject.tp_repr</code><a class="headerlink" href="#c.PyTypeObject.tp_repr" title="永久链接至目标">¶</a></dt>
<dd><p id="index-1">一个实现了内置函数 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 的函数的可选指针。</p>
<p>该签名与 <a class="reference internal" href="object.html#c.PyObject_Repr" title="PyObject_Repr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Repr()</span></code></a> 的相同:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_repr</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>该函数必须返回一个字符串或 Unicode 对象。 在理想情况下，该函数应当返回一个字符串，当将其传给 <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 时，只要有合适的环境，就会返回一个具有相同值的对象。 如果这不可行，则它应当返回一个以 <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code> 开头并以 <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code> 结尾的可被用来推断出对象的类型和值的字符串。</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
<p><strong>默认：</strong></p>
<p>如果未设置该字段，则返回 <code class="docutils literal notranslate"><span class="pre">&lt;%s</span> <span class="pre">object</span> <span class="pre">at</span> <span class="pre">%p&gt;</span></code> 形式的字符串，其中 <code class="docutils literal notranslate"><span class="pre">%s</span></code> 将替换为类型名称，<code class="docutils literal notranslate"><span class="pre">%p</span></code> 将替换为对象的内存地址。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_as_number">
<a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods">PyNumberMethods</a>* <code class="sig-name descname">PyTypeObject.tp_as_number</code><a class="headerlink" href="#c.PyTypeObject.tp_as_number" title="永久链接至目标">¶</a></dt>
<dd><p>指向一个附加结构体的指针，其中包含只与执行数字协议的对象相关的字段。 这些字段的文档参见 <a class="reference internal" href="#number-structs"><span class="std std-ref">数字对象结构体</span></a>。</p>
<p><strong>继承：</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_number" title="PyTypeObject.tp_as_number"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_number</span></code></a> 字段不会被继承，但所包含的字段会被单独继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_as_sequence">
<a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods">PySequenceMethods</a>* <code class="sig-name descname">PyTypeObject.tp_as_sequence</code><a class="headerlink" href="#c.PyTypeObject.tp_as_sequence" title="永久链接至目标">¶</a></dt>
<dd><p>指向一个附加结构体的指针，其中包含只与执行序列协议的对象相关的字段。 这些字段的文档见 <a class="reference internal" href="#sequence-structs"><span class="std std-ref">序列对象结构体</span></a>。</p>
<p><strong>继承：</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_sequence" title="PyTypeObject.tp_as_sequence"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_sequence</span></code></a> 字段不会被继承，但所包含的字段会被单独继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_as_mapping">
<a class="reference internal" href="#c.PyMappingMethods" title="PyMappingMethods">PyMappingMethods</a>* <code class="sig-name descname">PyTypeObject.tp_as_mapping</code><a class="headerlink" href="#c.PyTypeObject.tp_as_mapping" title="永久链接至目标">¶</a></dt>
<dd><p>指向一个附加结构体的指针，其中包含只与执行映射协议的对象相关的字段。 这些字段的文档见 <a class="reference internal" href="#mapping-structs"><span class="std std-ref">映射对象结构体</span></a>。</p>
<p><strong>继承：</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_mapping" title="PyTypeObject.tp_as_mapping"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_mapping</span></code></a> 字段不会继承，但所包含的字段会被单独继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_hash">
<a class="reference internal" href="#c.hashfunc" title="hashfunc">hashfunc</a> <code class="sig-name descname">PyTypeObject.tp_hash</code><a class="headerlink" href="#c.PyTypeObject.tp_hash" title="永久链接至目标">¶</a></dt>
<dd><p id="index-2">一个指向实现了内置函数 <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 的函数的可选指针。</p>
<p>其签名与 <a class="reference internal" href="object.html#c.PyObject_Hash" title="PyObject_Hash"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Hash()</span></code></a> 的相同:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Py_hash_t</span><span class="w"> </span><span class="nf">tp_hash</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-1</span></code> 不应作为正常返回值被返回；当计算哈希值过程中发生错误时，函数应设置一个异常并返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p>
<p>When this field is not set (<em>and</em> <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_richcompare</span></code> is not set),
an attempt to take the hash of the object raises <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.
This is the same as setting it to <a class="reference internal" href="object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_HashNotImplemented()</span></code></a>.</p>
<p>此字段可被显式设为 <a class="reference internal" href="object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_HashNotImplemented()</span></code></a> 以阻止从父类型继承哈希方法。在 Python 层面这被解释为 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> 的等价物，使得 <code class="docutils literal notranslate"><span class="pre">isinstance(o,</span> <span class="pre">collections.Hashable)</span></code> 正确返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>.。请注意反过来也是如此：在 Python 层面设置一个类的 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> 会使得 <code class="docutils literal notranslate"><span class="pre">tp_hash</span></code> 槽位被设置为 <a class="reference internal" href="object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_HashNotImplemented()</span></code></a>。</p>
<p><strong>继承：</strong></p>
<p>分组: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_hash</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_richcompare</span></code></p>
<p>该字段会被子类型同 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a> 一起继承：当子类型的 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a> 均为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时子类型将同时继承 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_call">
<a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc">ternaryfunc</a> <code class="sig-name descname">PyTypeObject.tp_call</code><a class="headerlink" href="#c.PyTypeObject.tp_call" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的实现对象调用的指向函数的指针。 如果对象不是可调用对象则该值应为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 其签名与 <a class="reference internal" href="object.html#c.PyObject_Call" title="PyObject_Call"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Call()</span></code></a> 的相同:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_call</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">kwargs</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_str">
<a class="reference internal" href="#c.reprfunc" title="reprfunc">reprfunc</a> <code class="sig-name descname">PyTypeObject.tp_str</code><a class="headerlink" href="#c.PyTypeObject.tp_str" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的实现内置 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 操作的函数的指针。 （请注意 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 现在是一个类型，<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 是调用该类型的构造器。 该构造器将调用 <a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Str()</span></code></a> 执行实际操作，而 <a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Str()</span></code></a> 将调用该处理句柄。）</p>
<p>其签名与 <a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Str()</span></code></a> 的相同:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_str</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>该函数必须返回一个字符串或 Unicode 对象。 它应当是一个“友好”的对象字符串表示形式，因为这就是要在 <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 函数中与其他内容一起使用的表示形式。</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
<p><strong>默认：</strong></p>
<p>当未设置该字段时，将调用 <a class="reference internal" href="object.html#c.PyObject_Repr" title="PyObject_Repr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Repr()</span></code></a> 来返回一个字符串表示形式。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_getattro">
<a class="reference internal" href="#c.getattrofunc" title="getattrofunc">getattrofunc</a> <code class="sig-name descname">PyTypeObject.tp_getattro</code><a class="headerlink" href="#c.PyTypeObject.tp_getattro" title="永久链接至目标">¶</a></dt>
<dd><p>一个指向获取属性字符串函数的可选指针。</p>
<p>其签名与 <a class="reference internal" href="object.html#c.PyObject_GetAttr" title="PyObject_GetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetAttr()</span></code></a> 的相同:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_getattro</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</pre></div>
</div>
<p>可以方便地将该字段设为 <a class="reference internal" href="object.html#c.PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericGetAttr()</span></code></a>，它实现了查找对象属性的通常方式。</p>
<p><strong>继承：</strong></p>
<p>分组: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_getattr</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_getattro</span></code></p>
<p>该字段会被子类同 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a> 一起继承：当子类型的 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a> 均为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时子类型将同时继承 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a>。</p>
<p><strong>默认：</strong></p>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> 使用 <a class="reference internal" href="object.html#c.PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericGetAttr()</span></code></a>。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_setattro">
<a class="reference internal" href="#c.setattrofunc" title="setattrofunc">setattrofunc</a> <code class="sig-name descname">PyTypeObject.tp_setattro</code><a class="headerlink" href="#c.PyTypeObject.tp_setattro" title="永久链接至目标">¶</a></dt>
<dd><p>一个指向函数以便设置和删除属性的可选指针。</p>
<p>其签名与 <a class="reference internal" href="object.html#c.PyObject_SetAttr" title="PyObject_SetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetAttr()</span></code></a> 的相同:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_setattro</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>此外，还必须支持将 <em>value</em> 设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 来删除属性。 通常可以方便地将该字段设为 <a class="reference internal" href="object.html#c.PyObject_GenericSetAttr" title="PyObject_GenericSetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericSetAttr()</span></code></a>，它实现了设备对象属性的通常方式。</p>
<p><strong>继承：</strong></p>
<p>分组: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_setattr</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_setattro</span></code></p>
<p>该字段会被子类型同 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a> 一起继承：当子类型的 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a> 均为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时子类型将同时继承 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a>。</p>
<p><strong>默认：</strong></p>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> 使用 <a class="reference internal" href="object.html#c.PyObject_GenericSetAttr" title="PyObject_GenericSetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericSetAttr()</span></code></a>.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_as_buffer">
<a class="reference internal" href="#c.PyBufferProcs" title="PyBufferProcs">PyBufferProcs</a>* <code class="sig-name descname">PyTypeObject.tp_as_buffer</code><a class="headerlink" href="#c.PyTypeObject.tp_as_buffer" title="永久链接至目标">¶</a></dt>
<dd><p>指向一个包含只与实现缓冲区接口的对象相关的字段的附加结构体的指针。 这些字段的文档参见 <a class="reference internal" href="#buffer-structs"><span class="std std-ref">缓冲区对象结构体</span></a>。</p>
<p><strong>继承：</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_buffer</span></code></a> 字段不会被继承，但所包含的字段会被单独继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_flags">
unsigned long <code class="sig-name descname">PyTypeObject.tp_flags</code><a class="headerlink" href="#c.PyTypeObject.tp_flags" title="永久链接至目标">¶</a></dt>
<dd><p>该字段是针对多个旗标的位掩码。 某些旗标指明用于特定场景的变化语义；另一些旗标则用于指明类型对象（或通过 <a class="reference internal" href="#c.PyTypeObject.tp_as_number" title="PyTypeObject.tp_as_number"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_number</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_as_sequence" title="PyTypeObject.tp_as_sequence"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_sequence</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_as_mapping" title="PyTypeObject.tp_as_mapping"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_mapping</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_buffer</span></code></a> 引用的扩展结构体）中的特定字段，它们在历史上并不总是有效；如果这样的旗标位是清晰的，则它所保护的类型字段必须不可被访问并且必须被视为具有零或 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 值。</p>
<p><strong>继承：</strong></p>
<p>Inheritance of this field is complicated.  Most flag bits are inherited
individually, i.e. if the base type has a flag bit set, the subtype inherits
this flag bit.  The flag bits that pertain to extension structures are strictly
inherited if the extension structure is inherited, i.e. the base type's value of
the flag bit is copied into the subtype together with a pointer to the extension
structure.  The <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> flag bit is inherited together with
the <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> fields, i.e. if the
<a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> flag bit is clear in the subtype and the
<a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> fields in the subtype exist and have
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> values.</p>
<p><strong>默认：</strong></p>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> uses
<code class="docutils literal notranslate"><span class="pre">Py_TPFLAGS_DEFAULT</span> <span class="pre">|</span> <span class="pre">Py_TPFLAGS_BASETYPE</span></code>.</p>
<p><strong>位掩码:</strong></p>
<p>目前定义了以下位掩码；可以使用 <code class="docutils literal notranslate"><span class="pre">|</span></code> 运算符对它们进行 OR 运算以形成 <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a> 字段的值。 宏 <a class="reference internal" href="type.html#c.PyType_HasFeature" title="PyType_HasFeature"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_HasFeature()</span></code></a> 接受一个类型和一个旗标值 <em>tp</em> 和 <em>f</em>，并检查 <code class="docutils literal notranslate"><span class="pre">tp-&gt;tp_flags</span> <span class="pre">&amp;</span> <span class="pre">f</span></code> 是否为非零值。</p>
<dl class="data">
<dt id="Py_TPFLAGS_HEAPTYPE">
<code class="sig-name descname">Py_TPFLAGS_HEAPTYPE</code><a class="headerlink" href="#Py_TPFLAGS_HEAPTYPE" title="永久链接至目标">¶</a></dt>
<dd><p>This bit is set when the type object itself is allocated on the heap, for
example, types created dynamically using <a class="reference internal" href="type.html#c.PyType_FromSpec" title="PyType_FromSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromSpec()</span></code></a>.  In this
case, the <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_type</span></code> field of its instances is considered a reference to
the type, and the type object is INCREF'ed when a new instance is created, and
DECREF'ed when an instance is destroyed (this does not apply to instances of
subtypes; only the type referenced by the instance's ob_type gets INCREF'ed or
DECREF'ed).</p>
<p><strong>继承：</strong></p>
<p>？？？</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_BASETYPE">
<code class="sig-name descname">Py_TPFLAGS_BASETYPE</code><a class="headerlink" href="#Py_TPFLAGS_BASETYPE" title="永久链接至目标">¶</a></dt>
<dd><p>当此类型可被用作另一个类型的基类型时该比特位将被设置。 如果该比特位被清除，则此类型将无法被子类型化（类似于 Java 中的 &quot;final&quot; 类）。</p>
<p><strong>继承：</strong></p>
<p>？？？</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_READY">
<code class="sig-name descname">Py_TPFLAGS_READY</code><a class="headerlink" href="#Py_TPFLAGS_READY" title="永久链接至目标">¶</a></dt>
<dd><p>当此类型对象通过 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 被完全实例化时该比特位将被设置。</p>
<p><strong>继承：</strong></p>
<p>？？？</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_READYING">
<code class="sig-name descname">Py_TPFLAGS_READYING</code><a class="headerlink" href="#Py_TPFLAGS_READYING" title="永久链接至目标">¶</a></dt>
<dd><p>当 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 处在初始化此类型对象过程中时该比特位将被设置。</p>
<p><strong>继承：</strong></p>
<p>？？？</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_HAVE_GC">
<code class="sig-name descname">Py_TPFLAGS_HAVE_GC</code><a class="headerlink" href="#Py_TPFLAGS_HAVE_GC" title="永久链接至目标">¶</a></dt>
<dd><p>当此对象支持垃圾回收时该比特位将被设置。 如果设置了该比特位，则实例必须使用 <a class="reference internal" href="gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_New()</span></code></a> 来创建并使用 <a class="reference internal" href="gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Del()</span></code></a> 来销毁。 更多信息见 <a class="reference internal" href="gcsupport.html#supporting-cycle-detection"><span class="std std-ref">使对象类型支持循环垃圾回收</span></a> 一节。 该比特位还表明与类型对象中存在 GC 相关字段 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a>。</p>
<p><strong>继承：</strong></p>
<p>分组: <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_traverse</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_clear</span></code></p>
<p>The <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> flag bit is inherited
together with the <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_traverse</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_clear</span></code>
fields, i.e.  if the <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> flag bit is
clear in the subtype and the <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_traverse</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_clear</span></code> fields in the subtype exist and have <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
values.</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_DEFAULT">
<code class="sig-name descname">Py_TPFLAGS_DEFAULT</code><a class="headerlink" href="#Py_TPFLAGS_DEFAULT" title="永久链接至目标">¶</a></dt>
<dd><p>This is a bitmask of all the bits that pertain to the existence of certain
fields in the type object and its extension structures. Currently, it includes
the following bits: <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_STACKLESS_EXTENSION</span></code>,
<code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_VERSION_TAG</span></code>.</p>
<p><strong>继承：</strong></p>
<p>？？？</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_METHOD_DESCRIPTOR">
<code class="sig-name descname">Py_TPFLAGS_METHOD_DESCRIPTOR</code><a class="headerlink" href="#Py_TPFLAGS_METHOD_DESCRIPTOR" title="永久链接至目标">¶</a></dt>
<dd><p>这个位指明对象的行为类似于未绑定方法。</p>
<p>如果为 <code class="docutils literal notranslate"><span class="pre">type(meth)</span></code> 设置了该旗标，那么：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">meth.__get__(obj,</span> <span class="pre">cls)(*args,</span> <span class="pre">**kwds)</span></code> (其中 <code class="docutils literal notranslate"><span class="pre">obj</span></code> 不为 None) 必须等价于 <code class="docutils literal notranslate"><span class="pre">meth(obj,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">meth.__get__(None,</span> <span class="pre">cls)(*args,</span> <span class="pre">**kwds)</span></code> 必须等价于 <code class="docutils literal notranslate"><span class="pre">meth(*args,</span> <span class="pre">**kwds)</span></code>。</p></li>
</ul>
<p>此旗标为 <code class="docutils literal notranslate"><span class="pre">obj.meth()</span></code> 这样的典型方法调用启用优化：它将避免为 <code class="docutils literal notranslate"><span class="pre">obj.meth</span></code> 创建临时的“绑定方法”对象。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
<p><strong>继承：</strong></p>
<p>This flag is never inherited by heap types.
For extension types, it is inherited whenever
<a class="reference internal" href="#c.PyTypeObject.tp_descr_get" title="PyTypeObject.tp_descr_get"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descr_get</span></code></a> is inherited.</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_LONG_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_LONG_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_LONG_SUBCLASS" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_LIST_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_LIST_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_LIST_SUBCLASS" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_TUPLE_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_TUPLE_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_TUPLE_SUBCLASS" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_BYTES_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_BYTES_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_BYTES_SUBCLASS" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_UNICODE_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_UNICODE_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_UNICODE_SUBCLASS" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_DICT_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_DICT_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_DICT_SUBCLASS" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_BASE_EXC_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_BASE_EXC_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_BASE_EXC_SUBCLASS" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_TYPE_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_TYPE_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_TYPE_SUBCLASS" title="永久链接至目标">¶</a></dt>
<dd><p>这些旗标被 <a class="reference internal" href="long.html#c.PyLong_Check" title="PyLong_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyLong_Check()</span></code></a> 等函数用来快速确定一个类型是否为内置类型的子类；这样的专用检测比泛用检测如 <a class="reference internal" href="object.html#c.PyObject_IsInstance" title="PyObject_IsInstance"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_IsInstance()</span></code></a> 要更快速。 继承自内置类型的自定义类型应当正确地设置其 <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a>，否则与这样的类型进行交互的代码将因所使用的检测种类而出现不同的行为。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_HAVE_FINALIZE">
<code class="sig-name descname">Py_TPFLAGS_HAVE_FINALIZE</code><a class="headerlink" href="#Py_TPFLAGS_HAVE_FINALIZE" title="永久链接至目标">¶</a></dt>
<dd><p>当类型结构体中存在 <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a> 槽位时会设置这个比特位。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.8 版后已移除: </span>此旗标已不再是必要的，因为解释器会假定类型结构体中总是存在 <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a> 槽位。</p>
</div>
</dd></dl>

<dl class="data">
<dt id="_Py_TPFLAGS_HAVE_VECTORCALL">
<code class="sig-name descname">_Py_TPFLAGS_HAVE_VECTORCALL</code><a class="headerlink" href="#_Py_TPFLAGS_HAVE_VECTORCALL" title="永久链接至目标">¶</a></dt>
<dd><p>This bit is set when the class implements the vectorcall protocol.
See <a class="reference internal" href="#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code></a> for details.</p>
<p><strong>继承：</strong></p>
<p>This bit is set on <em>static</em> subtypes if <code class="docutils literal notranslate"><span class="pre">tp_flags</span></code> is not overridden:
a subtype inherits <code class="docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code> from its base type
when the subtype’s <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
and the subtype's <code class="docutils literal notranslate"><span class="pre">Py_TPFLAGS_HEAPTYPE</span></code> is not set.</p>
<p><a class="reference internal" href="#id4">Heap types</a> do not inherit <code class="docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>This flag is provisional and expected to become public in Python 3.9,
with a different name and, possibly, changed semantics.
If you use vectorcall, plan for updating your code for Python 3.9.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_doc">
const char* <code class="sig-name descname">PyTypeObject.tp_doc</code><a class="headerlink" href="#c.PyTypeObject.tp_doc" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的指向给出该类型对象的文档字符串的以 NUL 结束的 C 字符串的指针。 该指针被暴露为类型和类型实例上的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 属性。</p>
<p><strong>继承：</strong></p>
<p>这个字段 <em>不会</em> 被子类型继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_traverse">
<a class="reference internal" href="gcsupport.html#c.traverseproc" title="traverseproc">traverseproc</a> <code class="sig-name descname">PyTypeObject.tp_traverse</code><a class="headerlink" href="#c.PyTypeObject.tp_traverse" title="永久链接至目标">¶</a></dt>
<dd><p>An optional pointer to a traversal function for the garbage collector.  This is
only used if the <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> flag bit is set.  The signature is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">tp_traverse</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">visitproc</span><span class="w"> </span><span class="n">visit</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</pre></div>
</div>
<p>有关 Python 垃圾回收方案的更多信息可在 <a class="reference internal" href="gcsupport.html#supporting-cycle-detection"><span class="std std-ref">使对象类型支持循环垃圾回收</span></a> 一节中查看。</p>
<p>The <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> pointer is used by the garbage collector to detect
reference cycles. A typical implementation of a <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> function
simply calls <a class="reference internal" href="gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_VISIT()</span></code></a> on each of the instance's members that are Python
objects that the instance owns. For example, this is function <code class="xref c c-func docutils literal notranslate"><span class="pre">local_traverse()</span></code> from the
<a class="reference internal" href="../library/_thread.html#module-_thread" title="_thread: Low-level threading API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">_thread</span></code></a> extension module:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">local_traverse</span><span class="p">(</span><span class="n">localobject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">visitproc</span><span class="w"> </span><span class="n">visit</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">kw</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请注意 <a class="reference internal" href="gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_VISIT()</span></code></a> 仅能在可以参加循环引用的成员上被调用。 虽然还存在一个 <code class="docutils literal notranslate"><span class="pre">self-&gt;key</span></code> 成员，但它只能为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或 Python 字符串因而不能成为循环引用的一部分。</p>
<p>在另一方面，即使你知道某个成员永远不会成为循环引用的一部分，作为调试的辅助你仍然可能想要访问它因此 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 模块的 <a class="reference internal" href="../library/gc.html#gc.get_referents" title="gc.get_referents"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_referents()</span></code></a> 函数将会包括它。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>When implementing <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a>, only the members
that the instance <em>owns</em> (by having strong references to them) must be
visited. For instance, if an object supports weak references via the
<a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklist</span></code></a> slot, the pointer supporting
the linked list (what <em>tp_weaklist</em> points to) must <strong>not</strong> be
visited as the instance does not directly own the weak references to itself
(the weakreference list is there to support the weak reference machinery,
but the instance has no strong reference to the elements inside it, as they
are allowed to be removed even if the instance is still alive).</p>
</div>
<p>请注意 <a class="reference internal" href="gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_VISIT()</span></code></a> 要求传给 <code class="xref c c-func docutils literal notranslate"><span class="pre">local_traverse()</span></code> 的 <em>visit</em> 和 <em>arg</em> 形参具有指定的名称；不要随意命名它们。</p>
<p><strong>继承：</strong></p>
<p>分组: <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_traverse</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_clear</span></code></p>
<p>This field is inherited by subtypes together with <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> and the
<a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> flag bit: the flag bit, <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a>, and
<a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> are all inherited from the base type if they are all zero in
the subtype.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_clear">
<a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry">inquiry</a> <code class="sig-name descname">PyTypeObject.tp_clear</code><a class="headerlink" href="#c.PyTypeObject.tp_clear" title="永久链接至目标">¶</a></dt>
<dd><p>An optional pointer to a clear function for the garbage collector. This is only
used if the <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> flag bit is set.  The signature is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">tp_clear</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 成员函数被用来打破垃圾回收器在循环垃圾中检测到的循环引用。 总的来说，系统中的所有 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 函数必须合到一起以打破所有引用循环。 这是个微妙的问题，并且如有任何疑问都需要提供 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 函数。 例如，元组类型不会实现 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 函数，因为有可能证明完全用元组是不会构成循环引用的。 因此其他类型的 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 函数必须足以打破任何包含元组的循环。 这不是立即能明确的，并且很少会有避免实现 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 的适当理由。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 的实现应当丢弃实例指向其成员的可能为 Python 对象的引用，并将指向这些成员的指针设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，如下面的例子所示:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">local_clear</span><span class="p">(</span><span class="n">localobject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">kw</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_CLEAR()</span></code></a> macro should be used, because clearing references is
delicate:  the reference to the contained object must not be decremented until
after the pointer to the contained object is set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  This is because
decrementing the reference count may cause the contained object to become trash,
triggering a chain of reclamation activity that may include invoking arbitrary
Python code (due to finalizers, or weakref callbacks, associated with the
contained object). If it's possible for such code to reference <em>self</em> again,
it's important that the pointer to the contained object be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> at that time,
so that <em>self</em> knows the contained object can no longer be used.  The
<a class="reference internal" href="refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_CLEAR()</span></code></a> macro performs the operations in a safe order.</p>
<p>因为 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 函数的目的是打破循环引用，所以不需要清除所包含的对象如 Python 字符串或 Python 整数，它们无法参与循环引用。 另一方面，清除所包含的全部 Python 对象，并编写类型的 <a class="reference internal" href="#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dealloc</span></code></a> 函数来发起调用 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 也很方便。</p>
<p>有关 Python 垃圾回收方案的更多信息可在 <a class="reference internal" href="gcsupport.html#supporting-cycle-detection"><span class="std std-ref">使对象类型支持循环垃圾回收</span></a> 一节中查看。</p>
<p><strong>继承：</strong></p>
<p>分组: <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_traverse</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_clear</span></code></p>
<p>This field is inherited by subtypes together with <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> and the
<a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> flag bit: the flag bit, <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a>, and
<a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> are all inherited from the base type if they are all zero in
the subtype.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_richcompare">
<a class="reference internal" href="#c.richcmpfunc" title="richcmpfunc">richcmpfunc</a> <code class="sig-name descname">PyTypeObject.tp_richcompare</code><a class="headerlink" href="#c.PyTypeObject.tp_richcompare" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的指向富比较函数的指针，函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_richcompare</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">op</span><span class="p">);</span>
</pre></div>
</div>
<p>第一个形参将保证为 <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 所定义的类型的实例。</p>
<p>该函数应当返回比较的结果 (通常为 <code class="docutils literal notranslate"><span class="pre">Py_True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Py_False</span></code>)。 如果未定义比较运算，它必须返回 <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code>，如果发生了其他错误则它必须返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 并设置一个异常条件。</p>
<p>以下常量被定义用作 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a> 和 <a class="reference internal" href="object.html#c.PyObject_RichCompare" title="PyObject_RichCompare"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_RichCompare()</span></code></a> 的第三个参数：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 57%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>常量</p></th>
<th class="head"><p>对照</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_LT</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_LE</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_EQ</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_NE</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">!=</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_GT</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_GE</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></td>
</tr>
</tbody>
</table>
<p>定义以下宏是为了简化编写丰富的比较函数：</p>
<dl class="macro">
<dt id="c.Py_RETURN_RICHCOMPARE">
<code class="sig-name descname">Py_RETURN_RICHCOMPARE</code><span class="sig-paren">(</span>VAL_A, VAL_B, op<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_RETURN_RICHCOMPARE" title="永久链接至目标">¶</a></dt>
<dd><p>从该函数返回 <code class="docutils literal notranslate"><span class="pre">Py_True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Py_False</span></code>，这取决于比较的结果。 VAL_A 和 VAL_B 必须是可通过 C 比较运算符进行排序的（例如，它们可以为 C 整数或浮点数）。 第三个参数指明所请求的运算，与 <a class="reference internal" href="object.html#c.PyObject_RichCompare" title="PyObject_RichCompare"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_RichCompare()</span></code></a> 的参数一样。</p>
<p>The return value's reference count is properly incremented.</p>
<p>发生错误时，将设置异常并从该函数返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.7 新版功能.</span></p>
</div>
</dd></dl>

<p><strong>继承：</strong></p>
<p>分组: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_hash</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_richcompare</span></code></p>
<p>该字段会被子类型同 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a> 一起继承：当子类型的 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a> 均为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时子类型将同时继承 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>。</p>
<p><strong>默认：</strong></p>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> provides a <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_richcompare</span></code>
implementation, which may be inherited.  However, if only
<code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_hash</span></code> is defined, not even the inherited function is used
and instances of the type will not be able to participate in any
comparisons.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_weaklistoffset">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_weaklistoffset</code><a class="headerlink" href="#c.PyTypeObject.tp_weaklistoffset" title="永久链接至目标">¶</a></dt>
<dd><p>If the instances of this type are weakly referenceable, this field is greater
than zero and contains the offset in the instance structure of the weak
reference list head (ignoring the GC header, if present); this offset is used by
<code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_ClearWeakRefs()</span></code> and the <code class="xref c c-func docutils literal notranslate"><span class="pre">PyWeakref_*()</span></code> functions.  The
instance structure needs to include a field of type <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code></a> which is
initialized to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>不要将该字段与 <a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklist</span></code></a> 混淆；后者是指向类型对象本身的弱引用的列表头。</p>
<p><strong>继承：</strong></p>
<p>该字段会被子类型继承，但注意参阅下面列出的规则。 子类型可以覆盖此偏移量；这意味着子类型将使用不同于基类型的弱引用列表。 由于列表头总是通过 <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a> 找到的，所以这应该不成问题。</p>
<p>When a type defined by a class statement has no <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> declaration,
and none of its base types are weakly referenceable, the type is made weakly
referenceable by adding a weak reference list head slot to the instance layout
and setting the <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a> of that slot's offset.</p>
<p>When a type's <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> declaration contains a slot named
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__weakref__</span></code>, that slot becomes the weak reference list head for
instances of the type, and the slot's offset is stored in the type's
<a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a>.</p>
<p>When a type's <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> declaration does not contain a slot named
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__weakref__</span></code>, the type inherits its <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a> from its
base type.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_iter">
<a class="reference internal" href="#c.getiterfunc" title="getiterfunc">getiterfunc</a> <code class="sig-name descname">PyTypeObject.tp_iter</code><a class="headerlink" href="#c.PyTypeObject.tp_iter" title="永久链接至目标">¶</a></dt>
<dd><p>An optional pointer to a function that returns an iterator for the object.  Its
presence normally signals that the instances of this type are iterable (although
sequences may be iterable without this function).</p>
<p>此函数的签名与 <a class="reference internal" href="object.html#c.PyObject_GetIter" title="PyObject_GetIter"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetIter()</span></code></a> 的相同:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_iter</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_iternext">
<a class="reference internal" href="#c.iternextfunc" title="iternextfunc">iternextfunc</a> <code class="sig-name descname">PyTypeObject.tp_iternext</code><a class="headerlink" href="#c.PyTypeObject.tp_iternext" title="永久链接至目标">¶</a></dt>
<dd><p>An optional pointer to a function that returns the next item in an iterator.
The signature is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_iternext</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>当该迭代器被耗尽时，它必须返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>；<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 异常可能会设置也可能不设置。 当发生另一个错误时，它也必须返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 它的存在表明该类型的实际是迭代器。</p>
<p>迭代器类型也应当定义 <a class="reference internal" href="#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a> 函数，并且该函数应当返回迭代器实例本身（而不是新的迭代器实例）。</p>
<p>此函数的签名与 <a class="reference internal" href="iter.html#c.PyIter_Next" title="PyIter_Next"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyIter_Next()</span></code></a> 的相同。</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_methods">
struct <a class="reference internal" href="structures.html#c.PyMethodDef" title="PyMethodDef">PyMethodDef</a>* <code class="sig-name descname">PyTypeObject.tp_methods</code><a class="headerlink" href="#c.PyTypeObject.tp_methods" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的指向 <a class="reference internal" href="structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 结构体的以 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 结束的静态数组的指针，它声明了此类型的常规方法。</p>
<p>对于该数组中的每一项，都会向类型的字典 (参见下面的 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a>) 添加一个包含方法描述器的条目。</p>
<p><strong>继承：</strong></p>
<p>该字段不会被子类型所继承（方法是通过不同的机制来继承的）。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_members">
struct <a class="reference internal" href="structures.html#c.PyMemberDef" title="PyMemberDef">PyMemberDef</a>* <code class="sig-name descname">PyTypeObject.tp_members</code><a class="headerlink" href="#c.PyTypeObject.tp_members" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的指向 <a class="reference internal" href="structures.html#c.PyMemberDef" title="PyMemberDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemberDef</span></code></a> 结构体的以 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 结束的静态数组的指针，它声明了此类型的常规数据成员（字段或槽位）。</p>
<p>对于该数组中的每一项，都会向类型的字典 (参见下面的 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a>) 添加一个包含方法描述器的条目。</p>
<p><strong>继承：</strong></p>
<p>该字段不会被子类型所继承（成员是通过不同的机制来继承的）。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_getset">
struct <a class="reference internal" href="structures.html#c.PyGetSetDef" title="PyGetSetDef">PyGetSetDef</a>* <code class="sig-name descname">PyTypeObject.tp_getset</code><a class="headerlink" href="#c.PyTypeObject.tp_getset" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的指向 <a class="reference internal" href="structures.html#c.PyGetSetDef" title="PyGetSetDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyGetSetDef</span></code></a> 结构体的以 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 结束的静态数组的指针，它声明了此类型的实例中的被计算属性。</p>
<p>对于该数组中的每一项，都会向类型的字典 (参见下面的 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a>) 添加一个包含读写描述器的条目。</p>
<p><strong>继承：</strong></p>
<p>该字段不会被子类型所继承（被计算属性是通过不同的机制来继承的）。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_base">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a>* <code class="sig-name descname">PyTypeObject.tp_base</code><a class="headerlink" href="#c.PyTypeObject.tp_base" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的指向类型特征属性所继承的基类型的指针。 在这个层级上，只支持单继承；多重继承需要通过调用元类型动态地创建类型对象。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>槽位初始化需要遵循初始化全局变量的规则。 C99 要求初始化器为“地址常量”。 隐式转换为指针的函数指示器如 <a class="reference internal" href="type.html#c.PyType_GenericNew" title="PyType_GenericNew"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericNew()</span></code></a> 都是有效的 C99 地址常量。</p>
<p>However, the unary '&amp;' operator applied to a non-static variable
like <code class="xref c c-func docutils literal notranslate"><span class="pre">PyBaseObject_Type()</span></code> is not required to produce an address
constant.  Compilers may support this (gcc does), MSVC does not.
Both compilers are strictly standard conforming in this particular
behavior.</p>
<p>因此，应当在扩展模块的初始化函数中设置 <a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_base</span></code></a>。</p>
</div>
<p><strong>继承：</strong></p>
<p>该字段不会被子类型继承（显然）。</p>
<p><strong>默认：</strong></p>
<p>该字段默认为 <code class="docutils literal notranslate"><span class="pre">&amp;PyBaseObject_Type</span></code> (对 Python 程序员来说即 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 类型)。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_dict">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyTypeObject.tp_dict</code><a class="headerlink" href="#c.PyTypeObject.tp_dict" title="永久链接至目标">¶</a></dt>
<dd><p>类型的字典将由 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 存储到这里。</p>
<p>This field should normally be initialized to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> before PyType_Ready is
called; it may also be initialized to a dictionary containing initial attributes
for the type.  Once <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> has initialized the type, extra
attributes for the type may be added to this dictionary only if they don't
correspond to overloaded operations (like <a class="reference internal" href="../reference/datamodel.html#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>).</p>
<p><strong>继承：</strong></p>
<p>该字段不会被子类型所继承（但在这里定义的属性是通过不同的机制来继承的）。</p>
<p><strong>默认：</strong></p>
<p>如果该字段为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，<a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 将为它分配一个新字典。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>通过字典 C-API 使用 <a class="reference internal" href="dict.html#c.PyDict_SetItem" title="PyDict_SetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyDict_SetItem()</span></code></a> 或修改 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a> 是不安全的。</p>
</div>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_descr_get">
<a class="reference internal" href="#c.descrgetfunc" title="descrgetfunc">descrgetfunc</a> <code class="sig-name descname">PyTypeObject.tp_descr_get</code><a class="headerlink" href="#c.PyTypeObject.tp_descr_get" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的指向“描述器获取”函数的指针。</p>
<p>函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">tp_descr_get</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_descr_set">
<a class="reference internal" href="#c.descrsetfunc" title="descrsetfunc">descrsetfunc</a> <code class="sig-name descname">PyTypeObject.tp_descr_set</code><a class="headerlink" href="#c.PyTypeObject.tp_descr_set" title="永久链接至目标">¶</a></dt>
<dd><p>一个指向用于设置和删除描述器值的函数的选项指针。</p>
<p>函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">tp_descr_set</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>将 <em>value</em> 参数设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 以删除该值。</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_dictoffset">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_dictoffset</code><a class="headerlink" href="#c.PyTypeObject.tp_dictoffset" title="永久链接至目标">¶</a></dt>
<dd><p>如果该类型的实例具有一个包含实例变量的字典，则此字段将为非零值并包含该实例变量字典的类型的实例的偏移量；该偏移量将由 <a class="reference internal" href="object.html#c.PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericGetAttr()</span></code></a> 使用。</p>
<p>不要将该字段与 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a> 混淆；后者是由类型对象本身的属性组成的字典。</p>
<p>If the value of this field is greater than zero, it specifies the offset from
the start of the instance structure.  If the value is less than zero, it
specifies the offset from the <em>end</em> of the instance structure.  A negative
offset is more expensive to use, and should only be used when the instance
structure contains a variable-length part.  This is used for example to add an
instance variable dictionary to subtypes of <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>. Note
that the <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> field should account for the dictionary added to
the end in that case, even though the dictionary is not included in the basic
object layout.  On a system with a pointer size of 4 bytes,
<a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a> should be set to <code class="docutils literal notranslate"><span class="pre">-4</span></code> to indicate that the dictionary is
at the very end of the structure.</p>
<p>The real dictionary offset in an instance can be computed from a negative
<a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a> as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">dictoffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp_basicsize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">ob_size</span><span class="p">)</span><span class="o">*</span><span class="n">tp_itemsize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tp_dictoffset</span>
<span class="k">if</span><span class="w"> </span><span class="n">dictoffset</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">aligned</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">:</span>
<span class="w">    </span><span class="n">round</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p>where <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a> are
taken from the type object, and <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> is taken from the instance.  The
absolute value is taken because ints use the sign of <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> to
store the sign of the number.  (There's never a need to do this calculation
yourself; it is done for you by <code class="xref c c-func docutils literal notranslate"><span class="pre">_PyObject_GetDictPtr()</span></code>.)</p>
<p><strong>继承：</strong></p>
<p>This field is inherited by subtypes, but see the rules listed below. A subtype
may override this offset; this means that the subtype instances store the
dictionary at a difference offset than the base type.  Since the dictionary is
always found via <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a>, this should not be a problem.</p>
<p>When a type defined by a class statement has no <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> declaration,
and none of its base types has an instance variable dictionary, a dictionary
slot is added to the instance layout and the <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a> is set to
that slot's offset.</p>
<p>When a type defined by a class statement has a <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> declaration,
the type inherits its <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a> from its base type.</p>
<p>(Adding a slot named <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> to the <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> declaration does
not have the expected effect, it just causes confusion.  Maybe this should be
added as a feature just like <code class="xref py py-attr docutils literal notranslate"><span class="pre">__weakref__</span></code> though.)</p>
<p><strong>默认：</strong></p>
<p>This slot has no default.  For static types, if the field is
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> then no <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> gets created for instances.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_init">
<a class="reference internal" href="#c.initproc" title="initproc">initproc</a> <code class="sig-name descname">PyTypeObject.tp_init</code><a class="headerlink" href="#c.PyTypeObject.tp_init" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的指向实例初始化函数的指针。</p>
<p>This function corresponds to the <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> method of classes.  Like
<a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>, it is possible to create an instance without calling
<a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>, and it is possible to reinitialize an instance by calling its
<a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> method again.</p>
<p>函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">tp_init</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">kwds</span><span class="p">);</span>
</pre></div>
</div>
<p>The self argument is the instance to be initialized; the <em>args</em> and <em>kwds</em>
arguments represent positional and keyword arguments of the call to
<a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>.</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a> 函数如果不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，将在通过调用类型正常创建其实例时被调用，即在类型的 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 函数返回一个该类型的实例时。 如果 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 函数返回了一个不是原始类型的子类型的其他类型的实例，则 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a> 函数不会被调用；如果 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 返回了一个原始类型的子类型的实例，则该子类型的 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a> 将被调用。</p>
<p>成功时返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>，发生错误时则返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 并在错误上设置一个异常。and sets an exception on error.</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
<p><strong>默认：</strong></p>
<p>For static types this field does not have a default.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_alloc">
<a class="reference internal" href="#c.allocfunc" title="allocfunc">allocfunc</a> <code class="sig-name descname">PyTypeObject.tp_alloc</code><a class="headerlink" href="#c.PyTypeObject.tp_alloc" title="永久链接至目标">¶</a></dt>
<dd><p>指向一个实例分配函数的可选指针。</p>
<p>函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_alloc</span><span class="p">(</span><span class="n">PyTypeObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">nitems</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>继承：</strong></p>
<p>该字段会被静态子类型继承，但不会被动态子类型（通过 class 语句创建的子类型）继承。</p>
<p><strong>默认：</strong></p>
<p>对于动态子类型，该字段总是会被设为 <a class="reference internal" href="type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericAlloc()</span></code></a>，以强制应用标准的堆分配策略。</p>
<p>For static subtypes, <code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> uses
<a class="reference internal" href="type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericAlloc()</span></code></a>.  That is the recommended value
for all statically defined types.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_new">
<a class="reference internal" href="#c.newfunc" title="newfunc">newfunc</a> <code class="sig-name descname">PyTypeObject.tp_new</code><a class="headerlink" href="#c.PyTypeObject.tp_new" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的指向实例创建函数的指针。</p>
<p>函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_new</span><span class="p">(</span><span class="n">PyTypeObject</span><span class="w"> </span><span class="o">*</span><span class="n">subtype</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">kwds</span><span class="p">);</span>
</pre></div>
</div>
<p>The subtype argument is the type of the object being created; the <em>args</em> and
<em>kwds</em> arguments represent positional and keyword arguments of the call to the
type.  Note that subtype doesn't have to equal the type whose <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a>
function is called; it may be a subtype of that type (but not an unrelated
type).</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 函数应当调用 <code class="docutils literal notranslate"><span class="pre">subtype-&gt;tp_alloc(subtype,</span> <span class="pre">nitems)</span></code> 来为对象分配空间，然后只执行绝对有必要的进一步初始化操作。 可以安全地忽略或重复的初始化操作应当放在 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a> 处理句柄中。 一个关键的规则是对于不可变类型来说，所有初始化操作都应当在 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 中发生，而对于可变类型，大部分初始化操作都应当推迟到 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a> 再执行。</p>
<p><strong>继承：</strong></p>
<p>This field is inherited by subtypes, except it is not inherited by static types
whose <a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_base</span></code></a> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or <code class="docutils literal notranslate"><span class="pre">&amp;PyBaseObject_Type</span></code>.</p>
<p><strong>默认：</strong></p>
<p>For static types this field has no default.  This means if the
slot is defined as <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the type cannot be called to create new
instances; presumably there is some other way to create
instances, like a factory function.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_free">
<a class="reference internal" href="#c.freefunc" title="freefunc">freefunc</a> <code class="sig-name descname">PyTypeObject.tp_free</code><a class="headerlink" href="#c.PyTypeObject.tp_free" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的指向实例释放函数的指针。 函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">tp_free</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>一个兼容该签名的初始化器是 <a class="reference internal" href="memory.html#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a>。</p>
<p><strong>继承：</strong></p>
<p>该字段会被静态子类型继承，但不会被动态子类型（通过 class 语句创建的子类型）继承</p>
<p><strong>默认：</strong></p>
<p>In dynamic subtypes, this field is set to a deallocator suitable to
match <a class="reference internal" href="type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericAlloc()</span></code></a> and the value of the
<a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> flag bit.</p>
<p>对于静态子类型，<code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> 使用 PyObject_Del.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_is_gc">
<a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry">inquiry</a> <code class="sig-name descname">PyTypeObject.tp_is_gc</code><a class="headerlink" href="#c.PyTypeObject.tp_is_gc" title="永久链接至目标">¶</a></dt>
<dd><p>可选的指向垃圾回收器所调用的函数的指针。</p>
<p>The garbage collector needs to know whether a particular object is collectible
or not.  Normally, it is sufficient to look at the object's type's
<a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a> field, and check the <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> flag bit.  But
some types have a mixture of statically and dynamically allocated instances, and
the statically allocated instances are not collectible.  Such types should
define this function; it should return <code class="docutils literal notranslate"><span class="pre">1</span></code> for a collectible instance, and
<code class="docutils literal notranslate"><span class="pre">0</span></code> for a non-collectible instance. The signature is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">tp_is_gc</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>(The only example of this are types themselves.  The metatype,
<a class="reference internal" href="type.html#c.PyType_Type" title="PyType_Type"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyType_Type</span></code></a>, defines this function to distinguish between statically
and dynamically allocated types.)</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
<p><strong>默认：</strong></p>
<p>This slot has no default.  If this field is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>,
<a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> is used as the functional equivalent.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_bases">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyTypeObject.tp_bases</code><a class="headerlink" href="#c.PyTypeObject.tp_bases" title="永久链接至目标">¶</a></dt>
<dd><p>基类型的元组。</p>
<p>This is set for types created by a class statement.  It should be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for
statically defined types.</p>
<p><strong>继承：</strong></p>
<p>这个字段不会被继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_mro">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyTypeObject.tp_mro</code><a class="headerlink" href="#c.PyTypeObject.tp_mro" title="永久链接至目标">¶</a></dt>
<dd><p>包含基类型的扩展集的元组，以类型本身开始并以 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 作为结束，使用方法解析顺序。</p>
<p><strong>继承：</strong></p>
<p>这个字段不会被继承；它是通过 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 计算得到的。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_cache">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyTypeObject.tp_cache</code><a class="headerlink" href="#c.PyTypeObject.tp_cache" title="永久链接至目标">¶</a></dt>
<dd><p>尚未使用。 仅供内部使用。</p>
<p><strong>继承：</strong></p>
<p>这个字段不会被继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_subclasses">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyTypeObject.tp_subclasses</code><a class="headerlink" href="#c.PyTypeObject.tp_subclasses" title="永久链接至目标">¶</a></dt>
<dd><p>由对子类的弱引用组成的列表。 仅供内部使用。</p>
<p><strong>继承：</strong></p>
<p>这个字段不会被继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_weaklist">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyTypeObject.tp_weaklist</code><a class="headerlink" href="#c.PyTypeObject.tp_weaklist" title="永久链接至目标">¶</a></dt>
<dd><p>弱引用列表头，用于指向该类型对象的弱引用。 不会被继承。 仅限内部使用。</p>
<p><strong>继承：</strong></p>
<p>这个字段不会被继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_del">
<a class="reference internal" href="#c.destructor" title="destructor">destructor</a> <code class="sig-name descname">PyTypeObject.tp_del</code><a class="headerlink" href="#c.PyTypeObject.tp_del" title="永久链接至目标">¶</a></dt>
<dd><p>该字段已被弃用。 请改用 <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a>。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_version_tag">
unsigned int <code class="sig-name descname">PyTypeObject.tp_version_tag</code><a class="headerlink" href="#c.PyTypeObject.tp_version_tag" title="永久链接至目标">¶</a></dt>
<dd><p>用于索引至方法缓存。 仅限内部使用。</p>
<p><strong>继承：</strong></p>
<p>这个字段不会被继承。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_finalize">
<a class="reference internal" href="#c.destructor" title="destructor">destructor</a> <code class="sig-name descname">PyTypeObject.tp_finalize</code><a class="headerlink" href="#c.PyTypeObject.tp_finalize" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的指向实例最终化函数的指针。 函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">tp_finalize</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>如果设置了 <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a>，解释器将在最终化特定实例时调用它一次。 它将由垃圾回收器调用（如果实例是单独循环引用的一部分）或是在对象被释放之前被调用。 不论是哪种方式，它都肯定会在尝试打破循环引用之前被调用，以确保它所操作的对象处于正常状态。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a> 不应改变当前异常状态；因此，编写非关键终结器的推荐做法如下:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">local_finalize</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">error_type</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">error_value</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">error_traceback</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Save the current exception, if any. */</span>
<span class="w">    </span><span class="n">PyErr_Fetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">error_type</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">error_value</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">error_traceback</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* ... */</span>

<span class="w">    </span><span class="cm">/* Restore the saved exception. */</span>
<span class="w">    </span><span class="n">PyErr_Restore</span><span class="p">(</span><span class="n">error_type</span><span class="p">,</span><span class="w"> </span><span class="n">error_value</span><span class="p">,</span><span class="w"> </span><span class="n">error_traceback</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For this field to be taken into account (even through inheritance),
you must also set the <a class="reference internal" href="#Py_TPFLAGS_HAVE_FINALIZE" title="Py_TPFLAGS_HAVE_FINALIZE"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_FINALIZE</span></code></a> flags bit.</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>&quot;安全的对象最终化&quot; (<span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0442"><strong>PEP 442</strong></a>)</p>
</div>
</dd></dl>

<p>The remaining fields are only defined if the feature test macro
<code class="xref py py-const docutils literal notranslate"><span class="pre">COUNT_ALLOCS</span></code> is defined, and are for internal use only. They are
documented here for completeness.  None of these fields are inherited by
subtypes.</p>
<dl class="member">
<dt id="c.PyTypeObject.tp_allocs">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_allocs</code><a class="headerlink" href="#c.PyTypeObject.tp_allocs" title="永久链接至目标">¶</a></dt>
<dd><p>Number of allocations.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_frees">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_frees</code><a class="headerlink" href="#c.PyTypeObject.tp_frees" title="永久链接至目标">¶</a></dt>
<dd><p>Number of frees.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_maxalloc">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_maxalloc</code><a class="headerlink" href="#c.PyTypeObject.tp_maxalloc" title="永久链接至目标">¶</a></dt>
<dd><p>Maximum simultaneously allocated objects.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_prev">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a>* <code class="sig-name descname">PyTypeObject.tp_prev</code><a class="headerlink" href="#c.PyTypeObject.tp_prev" title="永久链接至目标">¶</a></dt>
<dd><p>Pointer to the previous type object with a non-zero <a class="reference internal" href="#c.PyTypeObject.tp_allocs" title="PyTypeObject.tp_allocs"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_allocs</span></code></a> field.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_next">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a>* <code class="sig-name descname">PyTypeObject.tp_next</code><a class="headerlink" href="#c.PyTypeObject.tp_next" title="永久链接至目标">¶</a></dt>
<dd><p>Pointer to the next type object with a non-zero <a class="reference internal" href="#c.PyTypeObject.tp_allocs" title="PyTypeObject.tp_allocs"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_allocs</span></code></a> field.</p>
</dd></dl>

<p>另外还需要注意，在应用垃圾回收机制的 Python 中，<a class="reference internal" href="#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dealloc</span></code></a> 可以从任意 Python 线程被调用，而不仅是创建该对象的线程（如果对象成为引用计数循环的一部分，则该循环可能会被任何线程上的垃圾回收操作所回收）。 这对 Python API 调用来说不是问题，因为 tp_dealloc 调用所在的线程将持有全局解释器锁（GIL）。 但是，如果被销毁的对象又销毁了来自其他 C 或 C++ 库的对象，则应当小心确保在调用 tp_dealloc 的线程上销毁这些对象不会破坏这些库的任何资源。</p>
</section>
<section id="heap-types">
<span id="id4"></span><h2>堆类型<a class="headerlink" href="#heap-types" title="永久链接至标题">¶</a></h2>
<p>在传统上，在 C 代码中定义的类型都是 <em>静态的</em>，也就是说，<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 结构体在代码中直接定义并使用 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 来初始化。</p>
<p>这就导致了与在 Python 中定义的类型相关联的类型限制：</p>
<ul class="simple">
<li><p>静态类型只能拥有一个基类；换句话说，他们不能使用多重继承。</p></li>
<li><p>静态类型对象（但并非它们的实例）是不可变对象。 不可能在 Python 中添加或修改类型对象的属性。</p></li>
<li><p>静态类型对象是跨 <a class="reference internal" href="init.html#sub-interpreter-support"><span class="std std-ref">子解释器</span></a> 共享的，因此它们不应包括任何子解释器专属的状态。</p></li>
</ul>
<p>Also, since <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> is not part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">stable ABI</span></a>,
any extension modules using static types must be compiled for a specific
Python minor version.</p>
<p>An alternative to static types is <em>heap-allocated types</em>, or <em>heap types</em>
for short, which correspond closely to classes created by Python's
<code class="docutils literal notranslate"><span class="pre">class</span></code> statement.</p>
<p>This is done by filling a <a class="reference internal" href="type.html#c.PyType_Spec" title="PyType_Spec"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyType_Spec</span></code></a> structure and calling
<a class="reference internal" href="type.html#c.PyType_FromSpecWithBases" title="PyType_FromSpecWithBases"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromSpecWithBases()</span></code></a>.</p>
</section>
</section>
<section id="number-object-structures">
<span id="number-structs"></span><h1>数字对象结构体<a class="headerlink" href="#number-object-structures" title="永久链接至标题">¶</a></h1>
<dl class="type">
<dt id="c.PyNumberMethods">
<code class="sig-name descname">PyNumberMethods</code><a class="headerlink" href="#c.PyNumberMethods" title="永久链接至目标">¶</a></dt>
<dd><p>该结构体持有指向被对象用来实现数字协议的函数的指针。 每个函数都被 <a class="reference internal" href="number.html#number"><span class="std std-ref">数字协议</span></a> 一节中记录的对应名称的函数所使用。</p>
<p>结构体定义如下:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_add</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_subtract</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_multiply</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_remainder</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_divmod</span><span class="p">;</span>
<span class="w">     </span><span class="n">ternaryfunc</span><span class="w"> </span><span class="n">nb_power</span><span class="p">;</span>
<span class="w">     </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">nb_negative</span><span class="p">;</span>
<span class="w">     </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">nb_positive</span><span class="p">;</span>
<span class="w">     </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">nb_absolute</span><span class="p">;</span>
<span class="w">     </span><span class="n">inquiry</span><span class="w"> </span><span class="n">nb_bool</span><span class="p">;</span>
<span class="w">     </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">nb_invert</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_lshift</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_rshift</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_and</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_xor</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_or</span><span class="p">;</span>
<span class="w">     </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">nb_int</span><span class="p">;</span>
<span class="w">     </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nb_reserved</span><span class="p">;</span>
<span class="w">     </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">nb_float</span><span class="p">;</span>

<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_add</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_subtract</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_multiply</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_remainder</span><span class="p">;</span>
<span class="w">     </span><span class="n">ternaryfunc</span><span class="w"> </span><span class="n">nb_inplace_power</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_lshift</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_rshift</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_and</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_xor</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_or</span><span class="p">;</span>

<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_floor_divide</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_true_divide</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_floor_divide</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_true_divide</span><span class="p">;</span>

<span class="w">     </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">nb_index</span><span class="p">;</span>

<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_matrix_multiply</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_matrix_multiply</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">PyNumberMethods</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>双目和三目函数必须检查其所有操作数的类型，并实现必要的转换（至少有一个操作数是所定义类型的实例）。 如果没有为所给出的操作数定义操作，则双目和三目函数必须返回 <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code>，如果发生了其他错误则它们必须返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 并设置一个异常。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>The <code class="xref c c-data docutils literal notranslate"><span class="pre">nb_reserved</span></code> field should always be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  It
was previously called <code class="xref c c-data docutils literal notranslate"><span class="pre">nb_long</span></code>, and was renamed in
Python 3.0.1.</p>
</div>
</dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_add">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_add</code><a class="headerlink" href="#c.PyNumberMethods.nb_add" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_subtract">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_subtract</code><a class="headerlink" href="#c.PyNumberMethods.nb_subtract" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_multiply">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_multiply</code><a class="headerlink" href="#c.PyNumberMethods.nb_multiply" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_remainder">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_remainder</code><a class="headerlink" href="#c.PyNumberMethods.nb_remainder" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_divmod">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_divmod</code><a class="headerlink" href="#c.PyNumberMethods.nb_divmod" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_power">
<a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc">ternaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_power</code><a class="headerlink" href="#c.PyNumberMethods.nb_power" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_negative">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_negative</code><a class="headerlink" href="#c.PyNumberMethods.nb_negative" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_positive">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_positive</code><a class="headerlink" href="#c.PyNumberMethods.nb_positive" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_absolute">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_absolute</code><a class="headerlink" href="#c.PyNumberMethods.nb_absolute" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_bool">
<a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry">inquiry</a> <code class="sig-name descname">PyNumberMethods.nb_bool</code><a class="headerlink" href="#c.PyNumberMethods.nb_bool" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_invert">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_invert</code><a class="headerlink" href="#c.PyNumberMethods.nb_invert" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_lshift">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_lshift</code><a class="headerlink" href="#c.PyNumberMethods.nb_lshift" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_rshift">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_rshift</code><a class="headerlink" href="#c.PyNumberMethods.nb_rshift" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_and">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_and</code><a class="headerlink" href="#c.PyNumberMethods.nb_and" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_xor">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_xor</code><a class="headerlink" href="#c.PyNumberMethods.nb_xor" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_or">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_or</code><a class="headerlink" href="#c.PyNumberMethods.nb_or" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_int">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_int</code><a class="headerlink" href="#c.PyNumberMethods.nb_int" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_reserved">
void *<code class="sig-name descname">PyNumberMethods.nb_reserved</code><a class="headerlink" href="#c.PyNumberMethods.nb_reserved" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_float">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_float</code><a class="headerlink" href="#c.PyNumberMethods.nb_float" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_add">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_add</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_add" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_subtract">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_subtract</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_subtract" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_multiply">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_multiply</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_multiply" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_remainder">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_remainder</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_remainder" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_power">
<a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc">ternaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_power</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_power" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_lshift">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_lshift</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_lshift" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_rshift">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_rshift</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_rshift" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_and">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_and</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_and" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_xor">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_xor</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_xor" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_or">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_or</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_or" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_floor_divide">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_floor_divide</code><a class="headerlink" href="#c.PyNumberMethods.nb_floor_divide" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_true_divide">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_true_divide</code><a class="headerlink" href="#c.PyNumberMethods.nb_true_divide" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_floor_divide">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_floor_divide</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_floor_divide" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_true_divide">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_true_divide</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_true_divide" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_index">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_index</code><a class="headerlink" href="#c.PyNumberMethods.nb_index" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_matrix_multiply">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_matrix_multiply</code><a class="headerlink" href="#c.PyNumberMethods.nb_matrix_multiply" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_matrix_multiply">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_matrix_multiply</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_matrix_multiply" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

</section>
<section id="mapping-object-structures">
<span id="mapping-structs"></span><h1>映射对象结构体<a class="headerlink" href="#mapping-object-structures" title="永久链接至标题">¶</a></h1>
<dl class="type">
<dt id="c.PyMappingMethods">
<code class="sig-name descname">PyMappingMethods</code><a class="headerlink" href="#c.PyMappingMethods" title="永久链接至目标">¶</a></dt>
<dd><p>该结构体持有指向对象用于实现映射协议的函数的指针。 它有三个成员：</p>
</dd></dl>

<dl class="member">
<dt id="c.PyMappingMethods.mp_length">
<a class="reference internal" href="#c.lenfunc" title="lenfunc">lenfunc</a> <code class="sig-name descname">PyMappingMethods.mp_length</code><a class="headerlink" href="#c.PyMappingMethods.mp_length" title="永久链接至目标">¶</a></dt>
<dd><p>该函数将被 <a class="reference internal" href="mapping.html#c.PyMapping_Size" title="PyMapping_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMapping_Size()</span></code></a> 和 <a class="reference internal" href="object.html#c.PyObject_Size" title="PyObject_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Size()</span></code></a> 使用，并具有相同的签名。 如果对象没有定义长度则此槽位可被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyMappingMethods.mp_subscript">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyMappingMethods.mp_subscript</code><a class="headerlink" href="#c.PyMappingMethods.mp_subscript" title="永久链接至目标">¶</a></dt>
<dd><p>该函数将被 <a class="reference internal" href="object.html#c.PyObject_GetItem" title="PyObject_GetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetItem()</span></code></a> 和 <a class="reference internal" href="sequence.html#c.PySequence_GetSlice" title="PySequence_GetSlice"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_GetSlice()</span></code></a> 使用，并具有与 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetItem()</span></code> 相同的签名。 此槽位必须被填充以便 <a class="reference internal" href="mapping.html#c.PyMapping_Check" title="PyMapping_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMapping_Check()</span></code></a> 函数返回 <code class="docutils literal notranslate"><span class="pre">1</span></code>，否则它可以为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyMappingMethods.mp_ass_subscript">
<a class="reference internal" href="#c.objobjargproc" title="objobjargproc">objobjargproc</a> <code class="sig-name descname">PyMappingMethods.mp_ass_subscript</code><a class="headerlink" href="#c.PyMappingMethods.mp_ass_subscript" title="永久链接至目标">¶</a></dt>
<dd><p>This function is used by <a class="reference internal" href="object.html#c.PyObject_SetItem" title="PyObject_SetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetItem()</span></code></a>,
<a class="reference internal" href="object.html#c.PyObject_DelItem" title="PyObject_DelItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_DelItem()</span></code></a>, <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetSlice()</span></code> and
<code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_DelSlice()</span></code>.  It has the same signature as
<code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetItem()</span></code>, but <em>v</em> can also be set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> to delete
an item.  If this slot is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the object does not support item
assignment and deletion.</p>
</dd></dl>

</section>
<section id="sequence-object-structures">
<span id="sequence-structs"></span><h1>序列对象结构体<a class="headerlink" href="#sequence-object-structures" title="永久链接至标题">¶</a></h1>
<dl class="type">
<dt id="c.PySequenceMethods">
<code class="sig-name descname">PySequenceMethods</code><a class="headerlink" href="#c.PySequenceMethods" title="永久链接至目标">¶</a></dt>
<dd><p>该结构体持有指向对象用于实现序列协议的函数的指针。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_length">
<a class="reference internal" href="#c.lenfunc" title="lenfunc">lenfunc</a> <code class="sig-name descname">PySequenceMethods.sq_length</code><a class="headerlink" href="#c.PySequenceMethods.sq_length" title="永久链接至目标">¶</a></dt>
<dd><p>此函数被 <a class="reference internal" href="sequence.html#c.PySequence_Size" title="PySequence_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Size()</span></code></a> 和 <a class="reference internal" href="object.html#c.PyObject_Size" title="PyObject_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Size()</span></code></a> 所使用，并具有与它们相同的签名。 它还被用于通过 <a class="reference internal" href="#c.PySequenceMethods.sq_item" title="PySequenceMethods.sq_item"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_item</span></code></a> 和 <a class="reference internal" href="#c.PySequenceMethods.sq_ass_item" title="PySequenceMethods.sq_ass_item"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_ass_item</span></code></a> 槽位来处理负索引号。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_concat">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PySequenceMethods.sq_concat</code><a class="headerlink" href="#c.PySequenceMethods.sq_concat" title="永久链接至目标">¶</a></dt>
<dd><p>此函数被 <a class="reference internal" href="sequence.html#c.PySequence_Concat" title="PySequence_Concat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Concat()</span></code></a> 所使用并具有相同的签名。 在尝试通过 <a class="reference internal" href="#c.PyNumberMethods.nb_add" title="PyNumberMethods.nb_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_add</span></code></a> 槽位执行数值相加之后它还会被用于 <code class="docutils literal notranslate"><span class="pre">+</span></code> 运算符。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_repeat">
<a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc">ssizeargfunc</a> <code class="sig-name descname">PySequenceMethods.sq_repeat</code><a class="headerlink" href="#c.PySequenceMethods.sq_repeat" title="永久链接至目标">¶</a></dt>
<dd><p>此函数被 <a class="reference internal" href="sequence.html#c.PySequence_Repeat" title="PySequence_Repeat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Repeat()</span></code></a> 所使用并具有相同的签名。 在尝试通过 <a class="reference internal" href="#c.PyNumberMethods.nb_multiply" title="PyNumberMethods.nb_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_multiply</span></code></a> 槽位执行数值相乘之后它还会被用于 <code class="docutils literal notranslate"><span class="pre">*</span></code> 运算符。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_item">
<a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc">ssizeargfunc</a> <code class="sig-name descname">PySequenceMethods.sq_item</code><a class="headerlink" href="#c.PySequenceMethods.sq_item" title="永久链接至目标">¶</a></dt>
<dd><p>此函数被 <a class="reference internal" href="sequence.html#c.PySequence_GetItem" title="PySequence_GetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_GetItem()</span></code></a> 所使用并具有相同的签名。 在尝试通过 <a class="reference internal" href="#c.PyMappingMethods.mp_subscript" title="PyMappingMethods.mp_subscript"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_subscript</span></code></a> 槽位执行下标操作之后它还会被用于 <a class="reference internal" href="object.html#c.PyObject_GetItem" title="PyObject_GetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetItem()</span></code></a>。 该槽位必须被填充以便 <a class="reference internal" href="sequence.html#c.PySequence_Check" title="PySequence_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Check()</span></code></a> 函数返回 <code class="docutils literal notranslate"><span class="pre">1</span></code>，否则它可以为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>Negative indexes are handled as follows: if the <code class="xref py py-attr docutils literal notranslate"><span class="pre">sq_length</span></code> slot is
filled, it is called and the sequence length is used to compute a positive
index which is passed to <code class="xref py py-attr docutils literal notranslate"><span class="pre">sq_item</span></code>.  If <code class="xref py py-attr docutils literal notranslate"><span class="pre">sq_length</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>,
the index is passed as is to the function.</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_ass_item">
<a class="reference internal" href="#c.ssizeobjargproc" title="ssizeobjargproc">ssizeobjargproc</a> <code class="sig-name descname">PySequenceMethods.sq_ass_item</code><a class="headerlink" href="#c.PySequenceMethods.sq_ass_item" title="永久链接至目标">¶</a></dt>
<dd><p>此函数被 <a class="reference internal" href="sequence.html#c.PySequence_SetItem" title="PySequence_SetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_SetItem()</span></code></a> 所使用并具有相同的签名。 在尝试通过 <a class="reference internal" href="#c.PyMappingMethods.mp_ass_subscript" title="PyMappingMethods.mp_ass_subscript"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_ass_subscript</span></code></a> 槽位执行条目赋值和删除操作之后它还会被用于 <a class="reference internal" href="object.html#c.PyObject_SetItem" title="PyObject_SetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetItem()</span></code></a> 和 <a class="reference internal" href="object.html#c.PyObject_DelItem" title="PyObject_DelItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_DelItem()</span></code></a>。 如果对象不支持条目和删除则该槽位可以保持为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_contains">
<a class="reference internal" href="#c.objobjproc" title="objobjproc">objobjproc</a> <code class="sig-name descname">PySequenceMethods.sq_contains</code><a class="headerlink" href="#c.PySequenceMethods.sq_contains" title="永久链接至目标">¶</a></dt>
<dd><p>该函数可供 <a class="reference internal" href="sequence.html#c.PySequence_Contains" title="PySequence_Contains"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Contains()</span></code></a> 使用并具有相同的签名。 此槽位可以保持为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，在此情况下 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Contains()</span></code> 只需遍历该序列直到找到一个匹配。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_inplace_concat">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PySequenceMethods.sq_inplace_concat</code><a class="headerlink" href="#c.PySequenceMethods.sq_inplace_concat" title="永久链接至目标">¶</a></dt>
<dd><p>此函数被 <a class="reference internal" href="sequence.html#c.PySequence_InPlaceConcat" title="PySequence_InPlaceConcat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_InPlaceConcat()</span></code></a> 所使用并具有相同的签名。 它应当修改它的第一个操作数，并将其返回。 该槽位可以保持为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，在此情况下 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_InPlaceConcat()</span></code> 将回退到 <a class="reference internal" href="sequence.html#c.PySequence_Concat" title="PySequence_Concat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Concat()</span></code></a>。 在尝试通过 <a class="reference internal" href="#c.PyNumberMethods.nb_inplace_add" title="PyNumberMethods.nb_inplace_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_add</span></code></a> 槽位执行数字原地相加之后它还会被用于增强赋值运算符 <code class="docutils literal notranslate"><span class="pre">+=</span></code>。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_inplace_repeat">
<a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc">ssizeargfunc</a> <code class="sig-name descname">PySequenceMethods.sq_inplace_repeat</code><a class="headerlink" href="#c.PySequenceMethods.sq_inplace_repeat" title="永久链接至目标">¶</a></dt>
<dd><p>此函数被 <a class="reference internal" href="sequence.html#c.PySequence_InPlaceRepeat" title="PySequence_InPlaceRepeat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_InPlaceRepeat()</span></code></a> 所使用并具有相同的签名。 它应当修改它的第一个操作数，并将其返回。 该槽位可以保持为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，在此情况下 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_InPlaceRepeat()</span></code> 将回退到 <a class="reference internal" href="sequence.html#c.PySequence_Repeat" title="PySequence_Repeat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Repeat()</span></code></a>。 在尝试通过 <a class="reference internal" href="#c.PyNumberMethods.nb_inplace_multiply" title="PyNumberMethods.nb_inplace_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_multiply</span></code></a> 槽位执行数字原地相乘之后它还会被用于增强赋值运算符 <code class="docutils literal notranslate"><span class="pre">*=</span></code>。</p>
</dd></dl>

</section>
<section id="buffer-object-structures">
<span id="buffer-structs"></span><h1>缓冲区对象结构体<a class="headerlink" href="#buffer-object-structures" title="永久链接至标题">¶</a></h1>
<dl class="type">
<dt id="c.PyBufferProcs">
<code class="sig-name descname">PyBufferProcs</code><a class="headerlink" href="#c.PyBufferProcs" title="永久链接至目标">¶</a></dt>
<dd><p>此结构体持有指向 <a class="reference internal" href="buffer.html#bufferobjects"><span class="std std-ref">缓冲区协议</span></a> 所需要的函数的指针。 该协议定义了导出方对象要如何向消费方对象暴露其内部数据。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyBufferProcs.bf_getbuffer">
<a class="reference internal" href="#c.getbufferproc" title="getbufferproc">getbufferproc</a> <code class="sig-name descname">PyBufferProcs.bf_getbuffer</code><a class="headerlink" href="#c.PyBufferProcs.bf_getbuffer" title="永久链接至目标">¶</a></dt>
<dd><p>此函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">exporter</span><span class="p">,</span><span class="w"> </span><span class="n">Py_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">view</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
</pre></div>
</div>
<p>处理发给 <em>exporter</em> 的请求来填充 <em>flags</em> 所指定的 <em>view</em>。 除第 (3) 点外，此函数的实现必须执行以下步骤：</p>
<ol class="arabic simple">
<li><p>Check if the request can be met. If not, raise <code class="xref c c-data docutils literal notranslate"><span class="pre">PyExc_BufferError</span></code>,
set <code class="xref c c-data docutils literal notranslate"><span class="pre">view-&gt;obj</span></code> to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and return <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p></li>
<li><p>填充请求的字段。</p></li>
<li><p>递增用于保存导出次数的内部计数器。</p></li>
<li><p>Set <code class="xref c c-data docutils literal notranslate"><span class="pre">view-&gt;obj</span></code> to <em>exporter</em> and increment <code class="xref c c-data docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>.</p></li>
<li><p>返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p></li>
</ol>
<p>如果 <em>exporter</em> 是缓冲区提供方的链式或树型结构的一部分，则可以使用两种主要方案：</p>
<ul class="simple">
<li><p>Re-export: Each member of the tree acts as the exporting object and
sets <code class="xref c c-data docutils literal notranslate"><span class="pre">view-&gt;obj</span></code> to a new reference to itself.</p></li>
<li><p>Redirect: The buffer request is redirected to the root object of the
tree. Here, <code class="xref c c-data docutils literal notranslate"><span class="pre">view-&gt;obj</span></code> will be a new reference to the root
object.</p></li>
</ul>
<p><em>view</em> 中每个字段的描述参见 <a class="reference internal" href="buffer.html#buffer-structure"><span class="std std-ref">缓冲区结构体</span></a> 一节，导出方对于特定请求应当如何反应参见 <a class="reference internal" href="buffer.html#buffer-request-types"><span class="std std-ref">缓冲区请求类型</span></a> 一节。</p>
<p>所有在 <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> 结构体中被指向的内存都属于导出方并必须保持有效直到不再有任何消费方。 <a class="reference internal" href="buffer.html#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-member docutils literal notranslate"><span class="pre">format</span></code></a>, <a class="reference internal" href="buffer.html#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a>, <a class="reference internal" href="buffer.html#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a>, <a class="reference internal" href="buffer.html#c.Py_buffer.suboffsets" title="Py_buffer.suboffsets"><code class="xref c c-member docutils literal notranslate"><span class="pre">suboffsets</span></code></a> 和 <a class="reference internal" href="buffer.html#c.Py_buffer.internal" title="Py_buffer.internal"><code class="xref c c-member docutils literal notranslate"><span class="pre">internal</span></code></a> 对于消费方来说是只读的。</p>
<p><a class="reference internal" href="buffer.html#c.PyBuffer_FillInfo" title="PyBuffer_FillInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_FillInfo()</span></code></a> 提供了一种暴露简单字节缓冲区同时正确处理地所有请求类型的简便方式。</p>
<p><a class="reference internal" href="buffer.html#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a> 是针对包装此函数的消费方的接口。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyBufferProcs.bf_releasebuffer">
<a class="reference internal" href="#c.releasebufferproc" title="releasebufferproc">releasebufferproc</a> <code class="sig-name descname">PyBufferProcs.bf_releasebuffer</code><a class="headerlink" href="#c.PyBufferProcs.bf_releasebuffer" title="永久链接至目标">¶</a></dt>
<dd><p>此函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">exporter</span><span class="p">,</span><span class="w"> </span><span class="n">Py_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">view</span><span class="p">);</span>
</pre></div>
</div>
<p>处理释放缓冲区资源的请求。 如果不需要释放任何资源，则 <a class="reference internal" href="#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyBufferProcs.bf_releasebuffer</span></code></a> 可以为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 在其他情况下，此函数的标准实现将执行以下的可选步骤：</p>
<ol class="arabic simple">
<li><p>递减用于保存导出次数的内部计数器。</p></li>
<li><p>如果计数器为 <code class="docutils literal notranslate"><span class="pre">0</span></code>，则释放所有关联到 <em>view</em> 的内存。</p></li>
</ol>
<p>导出方必须使用 <a class="reference internal" href="buffer.html#c.Py_buffer.internal" title="Py_buffer.internal"><code class="xref c c-member docutils literal notranslate"><span class="pre">internal</span></code></a> 字段来记录缓冲区专属的资源。 该字段将确保恒定，而消费方则可能将原始缓冲区作为 <em>view</em> 参数传入。</p>
<p>This function MUST NOT decrement <code class="xref c c-data docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>, since that is
done automatically in <a class="reference internal" href="buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a> (this scheme is
useful for breaking reference cycles).</p>
<p><a class="reference internal" href="buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a> 是针对包装此函数的消费方的接口。</p>
</dd></dl>

</section>
<section id="async-object-structures">
<span id="async-structs"></span><h1>异步对象结构体<a class="headerlink" href="#async-object-structures" title="永久链接至标题">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
<dl class="type">
<dt id="c.PyAsyncMethods">
<code class="sig-name descname">PyAsyncMethods</code><a class="headerlink" href="#c.PyAsyncMethods" title="永久链接至目标">¶</a></dt>
<dd><p>此结构体将持有指向需要用来实现 <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> 和 <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> 对象的函数的指针。</p>
<p>结构体定义如下:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">am_await</span><span class="p">;</span>
<span class="w">    </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">am_aiter</span><span class="p">;</span>
<span class="w">    </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">am_anext</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">PyAsyncMethods</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="member">
<dt id="c.PyAsyncMethods.am_await">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyAsyncMethods.am_await</code><a class="headerlink" href="#c.PyAsyncMethods.am_await" title="永久链接至目标">¶</a></dt>
<dd><p>此函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">am_await</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>The returned object must be an iterator, i.e. <a class="reference internal" href="iter.html#c.PyIter_Check" title="PyIter_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyIter_Check()</span></code></a> must
return <code class="docutils literal notranslate"><span class="pre">1</span></code> for it.</p>
<p>如果一个对象不是 <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> 则此槽位可被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyAsyncMethods.am_aiter">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyAsyncMethods.am_aiter</code><a class="headerlink" href="#c.PyAsyncMethods.am_aiter" title="永久链接至目标">¶</a></dt>
<dd><p>此函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">am_aiter</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>Must return an <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> object.  See <a class="reference internal" href="../reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> for details.</p>
<p>如果一个对象没有实现异步迭代协议则此槽位可被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyAsyncMethods.am_anext">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyAsyncMethods.am_anext</code><a class="headerlink" href="#c.PyAsyncMethods.am_anext" title="永久链接至目标">¶</a></dt>
<dd><p>此函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">am_anext</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>Must return an <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> object.  See <a class="reference internal" href="../reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> for details.
This slot may be set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd></dl>

</section>
<section id="slot-type-typedefs">
<span id="id5"></span><h1>槽位类型 typedef<a class="headerlink" href="#slot-type-typedefs" title="永久链接至标题">¶</a></h1>
<dl class="type">
<dt id="c.allocfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*allocfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a><em> *cls</em>, Py_ssize_t<em> nitems</em><span class="sig-paren">)</span><a class="headerlink" href="#c.allocfunc" title="永久链接至目标">¶</a></dt>
<dd><p>The purpose of this function is to separate memory allocation from memory
initialization.  It should return a pointer to a block of memory of adequate
length for the instance, suitably aligned, and initialized to zeros, but with
<code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_refcnt</span></code> set to <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_type</span></code> set to the type argument.  If
the type's <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> is non-zero, the object's <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> field
should be initialized to <em>nitems</em> and the length of the allocated memory block
should be <code class="docutils literal notranslate"><span class="pre">tp_basicsize</span> <span class="pre">+</span> <span class="pre">nitems*tp_itemsize</span></code>, rounded up to a multiple of
<code class="docutils literal notranslate"><span class="pre">sizeof(void*)</span></code>; otherwise, <em>nitems</em> is not used and the length of the block
should be <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a>.</p>
<p>此函数不应执行任何其他实例初始化操作，即使是分配额外内存也不应执行；那应当由 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 来完成。</p>
</dd></dl>

<dl class="type">
<dt id="c.destructor">
void <code class="sig-name descname">(*destructor)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.destructor" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.vectorcallfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*vectorcallfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *const<em> *args</em>, size_t<em> nargsf</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *kwnames</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vectorcallfunc" title="永久链接至目标">¶</a></dt>
<dd><p>See <a class="reference internal" href="#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code></a>.</p>
<p>Arguments to <code class="docutils literal notranslate"><span class="pre">vectorcallfunc</span></code> are the same as for <a class="reference internal" href="object.html#c._PyObject_Vectorcall" title="_PyObject_Vectorcall"><code class="xref c c-func docutils literal notranslate"><span class="pre">_PyObject_Vectorcall()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="type">
<dt id="c.freefunc">
void <code class="sig-name descname">(*freefunc)</code><span class="sig-paren">(</span>void<em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.freefunc" title="永久链接至目标">¶</a></dt>
<dd><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a>。</p>
</dd></dl>

<dl class="type">
<dt id="c.newfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*newfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.newfunc" title="永久链接至目标">¶</a></dt>
<dd><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a>。</p>
</dd></dl>

<dl class="type">
<dt id="c.initproc">
int <code class="sig-name descname">(*initproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.initproc" title="永久链接至目标">¶</a></dt>
<dd><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a>。</p>
</dd></dl>

<dl class="type">
<dt id="c.reprfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*reprfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reprfunc" title="永久链接至目标">¶</a></dt>
<dd><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_repr</span></code></a>。</p>
</dd></dl>

<dl class="type">
<dt id="c.getattrfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*getattrfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *self</em>, char<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.getattrfunc" title="永久链接至目标">¶</a></dt>
<dd><p>返回对象的指定属性的值。</p>
</dd></dl>

<dl class="type">
<dt id="c.setattrfunc">
int <code class="sig-name descname">(*setattrfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *self</em>, char<em> *attr</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.setattrfunc" title="永久链接至目标">¶</a></dt>
<dd><p>为对象设置指定属性的值。 将 value 参数设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 将删除该属性。</p>
</dd></dl>

<dl class="type">
<dt id="c.getattrofunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*getattrofunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *self</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.getattrofunc" title="永久链接至目标">¶</a></dt>
<dd><p>返回对象的指定属性的值。</p>
<p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a>。</p>
</dd></dl>

<dl class="type">
<dt id="c.setattrofunc">
int <code class="sig-name descname">(*setattrofunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *self</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *attr</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.setattrofunc" title="永久链接至目标">¶</a></dt>
<dd><p>为对象设置指定属性的值。 将 value 参数设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 将删除该属性。</p>
<p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a>。</p>
</dd></dl>

<dl class="type">
<dt id="c.descrgetfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*descrgetfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.descrgetfunc" title="永久链接至目标">¶</a></dt>
<dd><p>See <code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descrget</span></code>.</p>
</dd></dl>

<dl class="type">
<dt id="c.descrsetfunc">
int <code class="sig-name descname">(*descrsetfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.descrsetfunc" title="永久链接至目标">¶</a></dt>
<dd><p>See <code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descrset</span></code>.</p>
</dd></dl>

<dl class="type">
<dt id="c.hashfunc">
Py_hash_t <code class="sig-name descname">(*hashfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hashfunc" title="永久链接至目标">¶</a></dt>
<dd><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>。</p>
</dd></dl>

<dl class="type">
<dt id="c.richcmpfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*richcmpfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, int<span class="sig-paren">)</span><a class="headerlink" href="#c.richcmpfunc" title="永久链接至目标">¶</a></dt>
<dd><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a>。</p>
</dd></dl>

<dl class="type">
<dt id="c.getiterfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*getiterfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.getiterfunc" title="永久链接至目标">¶</a></dt>
<dd><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a>。</p>
</dd></dl>

<dl class="type">
<dt id="c.iternextfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*iternextfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iternextfunc" title="永久链接至目标">¶</a></dt>
<dd><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iternext</span></code></a>。</p>
</dd></dl>

<dl class="type">
<dt id="c.lenfunc">
Py_ssize_t <code class="sig-name descname">(*lenfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lenfunc" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.getbufferproc">
int <code class="sig-name descname">(*getbufferproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer">Py_buffer</a><em> *</em>, int<span class="sig-paren">)</span><a class="headerlink" href="#c.getbufferproc" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.releasebufferproc">
void <code class="sig-name descname">(*releasebufferproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer">Py_buffer</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.releasebufferproc" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.unaryfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*unaryfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unaryfunc" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.binaryfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*binaryfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.binaryfunc" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.ternaryfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*ternaryfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ternaryfunc" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.ssizeargfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*ssizeargfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, Py_ssize_t<span class="sig-paren">)</span><a class="headerlink" href="#c.ssizeargfunc" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.ssizeobjargproc">
int <code class="sig-name descname">(*ssizeobjargproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, Py_ssize_t<span class="sig-paren">)</span><a class="headerlink" href="#c.ssizeobjargproc" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.objobjproc">
int <code class="sig-name descname">(*objobjproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.objobjproc" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.objobjargproc">
int <code class="sig-name descname">(*objobjargproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.objobjargproc" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

</section>
<section id="examples">
<span id="typedef-examples"></span><h1>例子<a class="headerlink" href="#examples" title="永久链接至标题">¶</a></h1>
<p>下面是一些 Python 类型定义的简单示例。 其中包括你可能会遇到的通常用法。 有些演示了令人困惑的边际情况。 要获取更多示例、实践信息以及教程，请参阅 <a class="reference internal" href="../extending/newtypes_tutorial.html#defining-new-types"><span class="std std-ref">自定义扩展类型：教程</span></a> 和 <a class="reference internal" href="../extending/newtypes.html#new-types-topics"><span class="std std-ref">定义扩展类型：已分类主题</span></a>。</p>
<p>A basic static type:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyObject_HEAD</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">MyObject</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="n">MyObject_Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_basicsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_doc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;My objects&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myobj_new</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_dealloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">myobj_dealloc</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_repr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">myobj_repr</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>你可能还会看到带有更繁琐的初始化器的较旧代码（特别是在 CPython 代码库中）:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="n">MyObject_Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span><span class="w">               </span><span class="cm">/* tp_name */</span>
<span class="w">    </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">),</span><span class="w">               </span><span class="cm">/* tp_basicsize */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_itemsize */</span>
<span class="w">    </span><span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">myobj_dealloc</span><span class="p">,</span><span class="w">      </span><span class="cm">/* tp_dealloc */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_vectorcall_offset */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_getattr */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_setattr */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_as_async */</span>
<span class="w">    </span><span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">myobj_repr</span><span class="p">,</span><span class="w">           </span><span class="cm">/* tp_repr */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_as_number */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_as_sequence */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_as_mapping */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_hash */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_call */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_str */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_getattro */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_setattro */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_as_buffer */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_flags */</span>
<span class="w">    </span><span class="s">&quot;My objects&quot;</span><span class="p">,</span><span class="w">                   </span><span class="cm">/* tp_doc */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_traverse */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_clear */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_richcompare */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_weaklistoffset */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_iter */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_iternext */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_methods */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_members */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_getset */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_base */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_dict */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_descr_get */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_descr_set */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_dictoffset */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_init */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_alloc */</span>
<span class="w">    </span><span class="n">myobj_new</span><span class="p">,</span><span class="w">                      </span><span class="cm">/* tp_new */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>一个支持弱引用、实例字典和哈希运算的类型:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyObject_HEAD</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">inst_dict</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">weakreflist</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">MyObject</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="n">MyObject_Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_basicsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_doc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;My objects&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_weaklistoffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offsetof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">,</span><span class="w"> </span><span class="n">weakreflist</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_dictoffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offsetof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">,</span><span class="w"> </span><span class="n">inst_dict</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Py_TPFLAGS_DEFAULT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Py_TPFLAGS_BASETYPE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Py_TPFLAGS_HAVE_GC</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myobj_new</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_traverse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">traverseproc</span><span class="p">)</span><span class="n">myobj_traverse</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_clear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">inquiry</span><span class="p">)</span><span class="n">myobj_clear</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_alloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyType_GenericNew</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_dealloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">myobj_dealloc</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_repr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">myobj_repr</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">hashfunc</span><span class="p">)</span><span class="n">myobj_hash</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_richcompare</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyBaseObject_Type</span><span class="p">.</span><span class="n">tp_richcompare</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A str subclass that cannot be subclassed and cannot be called
to create instances (e.g. uses a separate factory func):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyUnicodeObject</span><span class="w"> </span><span class="n">raw</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">extra</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">MyStr</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="n">MyStr_Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mymod.MyStr&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_basicsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyStr</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w">  </span><span class="c1">// set to &amp;PyUnicode_Type in module init</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_doc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my custom str&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_repr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">myobj_repr</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The simplest static type (with fixed-length instances):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyObject_HEAD</span>
<span class="p">}</span><span class="w"> </span><span class="n">MyObject</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="n">MyObject_Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The simplest static type (with variable-length instances):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyObject_VAR_HEAD</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">MyObject</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="n">MyObject_Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_basicsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_itemsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">),</span>
<span class="p">};</span>
</pre></div>
</div>
</section>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">类型对象</a><ul>
<li><a class="reference internal" href="#quick-reference">快速参考</a><ul>
<li><a class="reference internal" href="#tp-slots">&quot;tp_方法槽&quot;</a></li>
<li><a class="reference internal" href="#sub-slots">子方法槽（方法域）</a></li>
<li><a class="reference internal" href="#slot-typedefs">槽位 typedef</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pytypeobject-definition">PyTypeObject 定义</a></li>
<li><a class="reference internal" href="#pyobject-slots">PyObject 槽位</a></li>
<li><a class="reference internal" href="#pyvarobject-slots">PyVarObject 槽位</a></li>
<li><a class="reference internal" href="#pytypeobject-slots">PyTypeObject 槽</a></li>
<li><a class="reference internal" href="#heap-types">堆类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#number-object-structures">数字对象结构体</a></li>
<li><a class="reference internal" href="#mapping-object-structures">映射对象结构体</a></li>
<li><a class="reference internal" href="#sequence-object-structures">序列对象结构体</a></li>
<li><a class="reference internal" href="#buffer-object-structures">缓冲区对象结构体</a></li>
<li><a class="reference internal" href="#async-object-structures">异步对象结构体</a></li>
<li><a class="reference internal" href="#slot-type-typedefs">槽位类型 typedef</a></li>
<li><a class="reference internal" href="#examples">例子</a></li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="structures.html"
                        title="上一章">公用对象的结构</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="gcsupport.html"
                        title="下一章">使对象类型支持循环垃圾回收</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/c-api/typeobj.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="gcsupport.html" title="使对象类型支持循环垃圾回收"
             >下一页</a> |</li>
        <li class="right" >
          <a href="structures.html" title="公用对象的结构"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.8.19 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API 参考手册</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="objimpl.html" >对象实现支持</a> &#187;</li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 4月 29, 2024.
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>

  </body>
</html>